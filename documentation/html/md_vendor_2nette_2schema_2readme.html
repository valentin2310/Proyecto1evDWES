<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Proyecto1ev: readme</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="favicon.ico"/></td>
  <td id="projectalign">
   <div id="projectname">Proyecto1ev<span id="projectnumber">&#160;1</span>
   </div>
   <div id="projectbrief">Proyecto 1ยบ evaluacion, Laravel</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">readme</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="namespace_nette.html">Nette</a> Schema </p><hr  />
<p><a href="https://packagist.org/packages/nette/schema"><img src="https://img.shields.io/packagist/dm/nette/schema.svg" alt="Downloads this Month" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/nette/schema/actions"><img src="https://github.com/nette/schema/workflows/Tests/badge.svg?branch=master" alt="Tests" style="pointer-events: none;" class="inline"/></a> <a href="https://coveralls.io/github/nette/schema?branch=master"><img src="https://coveralls.io/repos/github/nette/schema/badge.svg?branch=master" alt="Coverage Status" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/nette/schema/releases"><img src="https://poser.pugx.org/nette/schema/v/stable" alt="Latest Stable Version" class="inline"/></a> <a href="https://github.com/nette/schema/blob/master/license.md"><img src="https://img.shields.io/badge/license-New%20BSD-blue.svg" alt="License" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md1291"></a>
Introduction</h1>
<p>A practical library for validation and normalization of data structures against a given schema with a smart &amp; easy-to-understand API.</p>
<p>Documentation can be found on the <a href="https://doc.nette.org/schema">website</a>.</p>
<p>Installation:</p>
<div class="fragment"><div class="line">composer require nette/schema</div>
</div><!-- fragment --><p>It requires PHP version 7.1 and supports PHP up to 8.3.</p>
<h2><a class="anchor" id="autotoc_md1292"></a>
&lt;a href="https://github.com/sponsors/dg" &gt;Support Me&lt;/a&gt;</h2>
<p>Do you like <a class="el" href="namespace_nette.html">Nette</a> Schema? Are you looking forward to the new features?</p>
<p><a href="https://github.com/sponsors/dg"><img src="https://files.nette.org/icons/donation-3.svg" alt="Buy me a coffee" style="pointer-events: none;" class="inline"/></a></p>
<p>Thank you!</p>
<h2><a class="anchor" id="autotoc_md1293"></a>
Basic Usage</h2>
<p>In variable <code>$schema</code> we have a validation schema (what exactly this means and how to create it we will say later) and in variable <code>$data</code> we have a data structure that we want to validate and normalize. This can be, for example, data sent by the user through an API, configuration file, etc.</p>
<p>The task is handled by the <a href="https://api.nette.org/schema/master/Nette/Schema/Processor.html">Nette\Schema\Processor</a> class, which processes the input and either returns normalized data or throws an <a href="https://api.nette.org/schema/master/Nette/Schema/ValidationException.html">Nette\Schema\ValidationException</a> exception on error.</p>
<div class="fragment"><div class="line">$processor = <span class="keyword">new</span> <a class="code hl_class" href="class_nette_1_1_schema_1_1_processor.html">Nette\Schema\Processor</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    $normalized = $processor-&gt;<a class="code hl_function" href="class_nette_1_1_schema_1_1_processor.html#aa31ab587f0fc3c1478662f0901dff21a">process</a>($schema, <a class="code hl_variable" href="update__mime__types_8php.html#ab9807831e7f54cb17039eb0b280ef902">$data</a>);</div>
<div class="line">} <span class="keywordflow">catch</span> (<a class="code hl_namespace" href="namespace_nette.html">Nette</a>\Schema\ValidationException $e) {</div>
<div class="line">    echo <span class="stringliteral">&#39;Data is invalid: &#39;</span> . $e-&gt;getMessage();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_nette_1_1_schema_1_1_processor_html"><div class="ttname"><a href="class_nette_1_1_schema_1_1_processor.html">Nette\Schema\Processor</a></div><div class="ttdef"><b>Definition</b> <a href="nette_2schema_2src_2_schema_2_processor_8php_source.html#l00018">Processor.php:19</a></div></div>
<div class="ttc" id="aclass_nette_1_1_schema_1_1_processor_html_aa31ab587f0fc3c1478662f0901dff21a"><div class="ttname"><a href="class_nette_1_1_schema_1_1_processor.html#aa31ab587f0fc3c1478662f0901dff21a">Nette\Schema\Processor\process</a></div><div class="ttdeci">process(Schema $schema, $data)</div><div class="ttdef"><b>Definition</b> <a href="nette_2schema_2src_2_schema_2_processor_8php_source.html#l00043">Processor.php:43</a></div></div>
<div class="ttc" id="anamespace_nette_html"><div class="ttname"><a href="namespace_nette.html">Nette</a></div></div>
<div class="ttc" id="aupdate__mime__types_8php_html_ab9807831e7f54cb17039eb0b280ef902"><div class="ttname"><a href="update__mime__types_8php.html#ab9807831e7f54cb17039eb0b280ef902">$data</a></div><div class="ttdeci">if('cli' !==\PHP_SAPI) $data</div><div class="ttdef"><b>Definition</b> <a href="update__mime__types_8php_source.html#l00017">update_mime_types.php:17</a></div></div>
</div><!-- fragment --><p>Method <code>$e-&gt;getMessages()</code> returns array of all message strings and <code>$e-&gt;getMessageObjects()</code> return all messages as <a href="https://api.nette.org/schema/master/Nette/Schema/Message.html">Nette\Schema\Message</a> objects.</p>
<h2><a class="anchor" id="autotoc_md1294"></a>
Defining Schema</h2>
<p>And now let's create a schema. The class <a href="https://api.nette.org/schema/master/Nette/Schema/Expect.html">Nette\Schema\Expect</a> is used to define it, we actually define expectations of what the data should look like. Let's say that the input data must be a structure (e.g. an array) containing elements <code>processRefund</code> of type bool and <code>refundAmount</code> of type int.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_nette_1_1_schema_1_1_expect.html">Nette\Schema\Expect</a>;</div>
<div class="line"> </div>
<div class="line">$schema = Expect::structure([</div>
<div class="line">    <span class="stringliteral">&#39;processRefund&#39;</span> =&gt; Expect::bool(),</div>
<div class="line">    <span class="stringliteral">&#39;refundAmount&#39;</span> =&gt; Expect::int(),</div>
<div class="line">]);</div>
<div class="ttc" id="aclass_nette_1_1_schema_1_1_expect_html"><div class="ttname"><a href="class_nette_1_1_schema_1_1_expect.html">Nette\Schema\Expect</a></div><div class="ttdef"><b>Definition</b> <a href="_expect_8php_source.html#l00033">Expect.php:34</a></div></div>
</div><!-- fragment --><p>We believe that the schema definition looks clear, even if you see it for the very first time.</p>
<p>Lets send the following data for validation:</p>
<div class="fragment"><div class="line"><a class="code hl_variable" href="update__mime__types_8php.html#ab9807831e7f54cb17039eb0b280ef902">$data</a> = [</div>
<div class="line">    <span class="stringliteral">&#39;processRefund&#39;</span> =&gt; <span class="keyword">true</span>,</div>
<div class="line">    <span class="stringliteral">&#39;refundAmount&#39;</span> =&gt; 17,</div>
<div class="line">];</div>
<div class="line"> </div>
<div class="line">$normalized = $processor-&gt;process($schema, <a class="code hl_variable" href="update__mime__types_8php.html#ab9807831e7f54cb17039eb0b280ef902">$data</a>); <span class="comment">// OK, it passes</span></div>
</div><!-- fragment --><p>The output, i.e. the value <code>$normalized</code>, is the object <code>stdClass</code>. If we want the output to be an array, we add a cast to schema &lsquo;Expect::structure([...])-&gt;castTo('array&rsquo;)`.</p>
<p>All elements of the structure are optional and have a default value <code>null</code>. Example:</p>
<div class="fragment"><div class="line"><a class="code hl_variable" href="update__mime__types_8php.html#ab9807831e7f54cb17039eb0b280ef902">$data</a> = [</div>
<div class="line">    <span class="stringliteral">&#39;refundAmount&#39;</span> =&gt; 17,</div>
<div class="line">];</div>
<div class="line"> </div>
<div class="line">$normalized = $processor-&gt;process($schema, <a class="code hl_variable" href="update__mime__types_8php.html#ab9807831e7f54cb17039eb0b280ef902">$data</a>); <span class="comment">// OK, it passes</span></div>
<div class="line"><span class="comment">// $normalized = {&#39;processRefund&#39; =&gt; null, &#39;refundAmount&#39; =&gt; 17}</span></div>
</div><!-- fragment --><p>The fact that the default value is <code>null</code> does not mean that it would be accepted in the input data &lsquo;'processRefund&rsquo; =&gt; null<code>. No, the input must be boolean, i.e. only</code>true<code>or</code>false<code>. We would have to explicitly allow</code>null<code>via</code>Expect::bool()-&gt;nullable()`.</p>
<p>An item can be made mandatory using <code>Expect::bool()-&gt;required()</code>. We change the default value to <code>false</code> using <code>Expect::bool()-&gt;default(false)</code> or shortly using <code>Expect::bool(false)</code>.</p>
<p>And what if we wanted to accept <code>1</code> and <code>0</code> besides booleans? Then we list the allowed values, which we will also normalize to boolean:</p>
<div class="fragment"><div class="line">$schema = Expect::structure([</div>
<div class="line">    <span class="stringliteral">&#39;processRefund&#39;</span> =&gt; Expect::anyOf(<span class="keyword">true</span>, <span class="keyword">false</span>, 1, 0)-&gt;castTo(<span class="stringliteral">&#39;bool&#39;</span>),</div>
<div class="line">    <span class="stringliteral">&#39;refundAmount&#39;</span> =&gt; Expect::int(),</div>
<div class="line">]);</div>
<div class="line"> </div>
<div class="line">$normalized = $processor-&gt;process($schema, <a class="code hl_variable" href="update__mime__types_8php.html#ab9807831e7f54cb17039eb0b280ef902">$data</a>);</div>
<div class="line">is_bool($normalized-&gt;processRefund); <span class="comment">// true</span></div>
</div><!-- fragment --><p>Now you know the basics of how the schema is defined and how the individual elements of the structure behave. We will now show what all the other elements can be used in defining a schema.</p>
<h2><a class="anchor" id="autotoc_md1295"></a>
Data Types: type()</h2>
<p>All standard PHP data types can be listed in the schema:</p>
<div class="fragment"><div class="line">Expect::string($default = <span class="keyword">null</span>)</div>
<div class="line">Expect::<span class="keywordtype">int</span>($default = null)</div>
<div class="line">Expect::<span class="keywordtype">float</span>($default = null)</div>
<div class="line">Expect::<span class="keywordtype">bool</span>($default = null)</div>
<div class="line">Expect::null()</div>
<div class="line">Expect::array($default = [])</div>
</div><!-- fragment --><p>And then all types <a href="https://doc.nette.org/validators#toc-validation-rules">supported by the Validators</a> via &lsquo;Expect::type('scalar&rsquo;)<code>or abbreviated</code>Expect::scalar()<code>. Also class or interface names are accepted, e.g.</code>Expect::type('AddressEntity')`.</p>
<p>You can also use union notation:</p>
<div class="fragment"><div class="line">Expect::type(<span class="stringliteral">&#39;bool|string|array&#39;</span>)</div>
</div><!-- fragment --><p>The default value is always <code>null</code> except for <code>array</code> and <code>list</code>, where it is an empty array. (A list is an array indexed in ascending order of numeric keys from zero, that is, a non-associative array).</p>
<h2><a class="anchor" id="autotoc_md1296"></a>
Array of Values: arrayOf() listOf()</h2>
<p>The array is too general structure, it is more useful to specify exactly what elements it can contain. For example, an array whose elements can only be strings:</p>
<div class="fragment"><div class="line">$schema = Expect::arrayOf(<span class="stringliteral">&#39;string&#39;</span>);</div>
<div class="line"> </div>
<div class="line">$processor-&gt;process($schema, [<span class="stringliteral">&#39;hello&#39;</span>, <span class="stringliteral">&#39;world&#39;</span>]); <span class="comment">// OK</span></div>
<div class="line">$processor-&gt;process($schema, [<span class="charliteral">&#39;a&#39;</span> =&gt; <span class="stringliteral">&#39;hello&#39;</span>, <span class="charliteral">&#39;b&#39;</span> =&gt; <span class="stringliteral">&#39;world&#39;</span>]); <span class="comment">// OK</span></div>
<div class="line">$processor-&gt;process($schema, [<span class="stringliteral">&#39;key&#39;</span> =&gt; 123]); <span class="comment">// ERROR: 123 is not a string</span></div>
</div><!-- fragment --><p>The second parameter can be used to specify keys (since version 1.2):</p>
<div class="fragment"><div class="line">$schema = Expect::arrayOf(<span class="stringliteral">&#39;string&#39;</span>, <span class="stringliteral">&#39;int&#39;</span>);</div>
<div class="line"> </div>
<div class="line">$processor-&gt;process($schema, [<span class="stringliteral">&#39;hello&#39;</span>, <span class="stringliteral">&#39;world&#39;</span>]); <span class="comment">// OK</span></div>
<div class="line">$processor-&gt;process($schema, [<span class="charliteral">&#39;a&#39;</span> =&gt; <span class="stringliteral">&#39;hello&#39;</span>]); <span class="comment">// ERROR: &#39;a&#39; is not int</span></div>
</div><!-- fragment --><p>The list is an indexed array:</p>
<div class="fragment"><div class="line">$schema = Expect::listOf(<span class="stringliteral">&#39;string&#39;</span>);</div>
<div class="line"> </div>
<div class="line">$processor-&gt;process($schema, [<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>]); <span class="comment">// OK</span></div>
<div class="line">$processor-&gt;process($schema, [<span class="charliteral">&#39;a&#39;</span>, 123]); <span class="comment">// ERROR: 123 is not a string</span></div>
<div class="line">$processor-&gt;process($schema, [<span class="stringliteral">&#39;key&#39;</span> =&gt; <span class="charliteral">&#39;a&#39;</span>]); <span class="comment">// ERROR: is not a list</span></div>
<div class="line">$processor-&gt;process($schema, [1 =&gt; <span class="charliteral">&#39;a&#39;</span>, 0 =&gt; <span class="charliteral">&#39;b&#39;</span>]); <span class="comment">// ERROR: is not a list</span></div>
</div><!-- fragment --><p>The parameter can also be a schema, so we can write:</p>
<div class="fragment"><div class="line">Expect::arrayOf(Expect::bool())</div>
</div><!-- fragment --><p>The default value is an empty array. If you specify a default value, it will be merged with the passed data. This can be disabled using <code>mergeDefaults(false)</code>.</p>
<h2><a class="anchor" id="autotoc_md1297"></a>
Enumeration: anyOf()</h2>
<p><code>anyOf()</code> is a set of values โโor schemas that a value can be. Here's how to write an array of elements that can be either &lsquo;'a&rsquo;<code>,</code>true<code>, or</code>null`:</p>
<div class="fragment"><div class="line">$schema = Expect::listOf(</div>
<div class="line">    Expect::anyOf(<span class="charliteral">&#39;a&#39;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>),</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">$processor-&gt;process($schema, [<span class="charliteral">&#39;a&#39;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="charliteral">&#39;a&#39;</span>]); <span class="comment">// OK</span></div>
<div class="line">$processor-&gt;process($schema, [<span class="charliteral">&#39;a&#39;</span>, <span class="keyword">false</span>]); <span class="comment">// ERROR: false does not belong there</span></div>
</div><!-- fragment --><p>The enumeration elements can also be schemas:</p>
<div class="fragment"><div class="line">$schema = Expect::listOf(</div>
<div class="line">    Expect::anyOf(Expect::string(), <span class="keyword">true</span>, <span class="keyword">null</span>),</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">$processor-&gt;process($schema, [<span class="stringliteral">&#39;foo&#39;</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="stringliteral">&#39;bar&#39;</span>]); <span class="comment">// OK</span></div>
<div class="line">$processor-&gt;process($schema, [123]); <span class="comment">// ERROR</span></div>
</div><!-- fragment --><p>The <code>anyOf()</code> method accepts variants as individual parameters, not as array. To pass it an array of values, use the unpacking operator <code>anyOf(...$variants)</code>.</p>
<p>The default value is <code>null</code>. Use the <code>firstIsDefault()</code> method to make the first element the default:</p>
<div class="fragment"><div class="line"><span class="comment">// default is &#39;hello&#39;</span></div>
<div class="line">Expect::anyOf(Expect::string(<span class="stringliteral">&#39;hello&#39;</span>), <span class="keyword">true</span>, <span class="keyword">null</span>)-&gt;firstIsDefault();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1298"></a>
Structures</h2>
<p>Structures are objects with defined keys. Each of these key =&gt; value pairs is referred to as a "property":</p>
<p>Structures accept arrays and objects and return objects <code>stdClass</code> (unless you change it with &lsquo;castTo('array&rsquo;)`, etc.).</p>
<p>By default, all properties are optional and have a default value of <code>null</code>. You can define mandatory properties using <code>required()</code>:</p>
<div class="fragment"><div class="line">$schema = Expect::structure([</div>
<div class="line">    <span class="stringliteral">&#39;required&#39;</span> =&gt; Expect::string()-&gt;required(),</div>
<div class="line">    <span class="stringliteral">&#39;optional&#39;</span> =&gt; Expect::string(), <span class="comment">// the default value is null</span></div>
<div class="line">]);</div>
<div class="line"> </div>
<div class="line">$processor-&gt;process($schema, [<span class="stringliteral">&#39;optional&#39;</span> =&gt; <span class="stringliteral">&#39;&#39;</span>]);</div>
<div class="line"><span class="comment">// ERROR: option &#39;required&#39; is missing</span></div>
<div class="line"> </div>
<div class="line">$processor-&gt;process($schema, [<span class="stringliteral">&#39;required&#39;</span> =&gt; <span class="stringliteral">&#39;foo&#39;</span>]);</div>
<div class="line"><span class="comment">// OK, returns {&#39;required&#39; =&gt; &#39;foo&#39;, &#39;optional&#39; =&gt; null}</span></div>
</div><!-- fragment --><p>If you do not want to output properties with only a default value, use <code>skipDefaults()</code>:</p>
<div class="fragment"><div class="line">$schema = Expect::structure([</div>
<div class="line">    <span class="stringliteral">&#39;required&#39;</span> =&gt; Expect::string()-&gt;required(),</div>
<div class="line">    <span class="stringliteral">&#39;optional&#39;</span> =&gt; Expect::string(),</div>
<div class="line">])-&gt;skipDefaults();</div>
<div class="line"> </div>
<div class="line">$processor-&gt;process($schema, [<span class="stringliteral">&#39;required&#39;</span> =&gt; <span class="stringliteral">&#39;foo&#39;</span>]);</div>
<div class="line"><span class="comment">// OK, returns {&#39;required&#39; =&gt; &#39;foo&#39;}</span></div>
</div><!-- fragment --><p>Although <code>null</code> is the default value of the <code>optional</code> property, it is not allowed in the input data (the value must be a string). Properties accepting <code>null</code> are defined using <code>nullable()</code>:</p>
<div class="fragment"><div class="line">$schema = Expect::structure([</div>
<div class="line">    <span class="stringliteral">&#39;optional&#39;</span> =&gt; Expect::string(),</div>
<div class="line">    <span class="stringliteral">&#39;nullable&#39;</span> =&gt; Expect::string()-&gt;nullable(),</div>
<div class="line">]);</div>
<div class="line"> </div>
<div class="line">$processor-&gt;process($schema, [<span class="stringliteral">&#39;optional&#39;</span> =&gt; <span class="keyword">null</span>]);</div>
<div class="line"><span class="comment">// ERROR: &#39;optional&#39; expects to be string, null given.</span></div>
<div class="line"> </div>
<div class="line">$processor-&gt;process($schema, [<span class="stringliteral">&#39;nullable&#39;</span> =&gt; <span class="keyword">null</span>]);</div>
<div class="line"><span class="comment">// OK, returns {&#39;optional&#39; =&gt; null, &#39;nullable&#39; =&gt; null}</span></div>
</div><!-- fragment --><p>By default, there can be no extra items in the input data:</p>
<div class="fragment"><div class="line">$schema = Expect::structure([</div>
<div class="line">    <span class="stringliteral">&#39;key&#39;</span> =&gt; Expect::string(),</div>
<div class="line">]);</div>
<div class="line"> </div>
<div class="line">$processor-&gt;process($schema, [<span class="stringliteral">&#39;additional&#39;</span> =&gt; 1]);</div>
<div class="line"><span class="comment">// ERROR: Unexpected item &#39;additional&#39;</span></div>
</div><!-- fragment --><p>Which we can change with <code>otherItems()</code>. As a parameter, we will specify the schema for each extra element:</p>
<div class="fragment"><div class="line">$schema = Expect::structure([</div>
<div class="line">    <span class="stringliteral">&#39;key&#39;</span> =&gt; Expect::string(),</div>
<div class="line">])-&gt;otherItems(Expect::int());</div>
<div class="line"> </div>
<div class="line">$processor-&gt;process($schema, [<span class="stringliteral">&#39;additional&#39;</span> =&gt; 1]); <span class="comment">// OK</span></div>
<div class="line">$processor-&gt;process($schema, [<span class="stringliteral">&#39;additional&#39;</span> =&gt; <span class="keyword">true</span>]); <span class="comment">// ERROR</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1299"></a>
Deprecations</h2>
<p>You can deprecate property using the <code>deprecated([string $message])</code> method. Deprecation notices are returned by <code>$processor-&gt;getWarnings()</code>:</p>
<div class="fragment"><div class="line">$schema = Expect::structure([</div>
<div class="line">    <span class="stringliteral">&#39;old&#39;</span> =&gt; Expect::int()-&gt;deprecated(<span class="stringliteral">&#39;The item %path% is deprecated&#39;</span>),</div>
<div class="line">]);</div>
<div class="line"> </div>
<div class="line">$processor-&gt;process($schema, [<span class="stringliteral">&#39;old&#39;</span> =&gt; 1]); <span class="comment">// OK</span></div>
<div class="line">$processor-&gt;getWarnings(); <span class="comment">// [&quot;The item &#39;old&#39; is deprecated&quot;]</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1300"></a>
Ranges: min() max()</h2>
<p>Use <code>min()</code> and <code>max()</code> to limit the number of elements for arrays:</p>
<div class="fragment"><div class="line"><span class="comment">// array, at least 10 items, maximum 20 items</span></div>
<div class="line">Expect::array()-&gt;min(10)-&gt;max(20);</div>
</div><!-- fragment --><p>For strings, limit their length:</p>
<div class="fragment"><div class="line"><span class="comment">// string, at least 10 characters long, maximum 20 characters</span></div>
<div class="line">Expect::string()-&gt;min(10)-&gt;max(20);</div>
</div><!-- fragment --><p>For numbers, limit their value:</p>
<div class="fragment"><div class="line"><span class="comment">// integer, between 10 and 20 inclusive</span></div>
<div class="line">Expect::int()-&gt;min(10)-&gt;max(20);</div>
</div><!-- fragment --><p>Of course, it is possible to mention only <code>min()</code>, or only <code>max()</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// string, maximum 20 characters</span></div>
<div class="line">Expect::string()-&gt;max(20);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1301"></a>
Regular Expressions: pattern()</h2>
<p>Using <code>pattern()</code>, you can specify a regular expression which the <b>whole</b> input string must match (i.e. as if it were wrapped in characters <code>^</code> a <code>$</code>):</p>
<div class="fragment"><div class="line"><span class="comment">// just 9 digits</span></div>
<div class="line">Expect::string()-&gt;pattern(<span class="stringliteral">&#39;\d{9}&#39;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1302"></a>
Custom Assertions: assert()</h2>
<p>You can add any other restrictions using <code>assert(callable $fn)</code>.</p>
<div class="fragment"><div class="line">$countIsEven = fn($v) =&gt; count($v) % 2 === 0;</div>
<div class="line"> </div>
<div class="line">$schema = Expect::arrayOf(<span class="stringliteral">&#39;string&#39;</span>)</div>
<div class="line">    -&gt;assert($countIsEven); <span class="comment">// the count must be even</span></div>
<div class="line"> </div>
<div class="line">$processor-&gt;process($schema, [<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>]); <span class="comment">// OK</span></div>
<div class="line">$processor-&gt;process($schema, [<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, <span class="charliteral">&#39;c&#39;</span>]); <span class="comment">// ERROR: 3 is not even</span></div>
</div><!-- fragment --><p>Or</p>
<div class="fragment"><div class="line">Expect::string()-&gt;assert(<span class="stringliteral">&#39;is_file&#39;</span>); <span class="comment">// the file must exist</span></div>
</div><!-- fragment --><p>You can add your own description for each assertion. It will be part of the error message.</p>
<div class="fragment"><div class="line">$schema = Expect::arrayOf(<span class="stringliteral">&#39;string&#39;</span>)</div>
<div class="line">    -&gt;assert($countIsEven, <span class="stringliteral">&#39;Even items in array&#39;</span>);</div>
<div class="line"> </div>
<div class="line">$processor-&gt;process($schema, [<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, <span class="charliteral">&#39;c&#39;</span>]);</div>
<div class="line"><span class="comment">// Failed assertion &quot;Even items in array&quot; for item with value array.</span></div>
</div><!-- fragment --><p>The method can be called repeatedly to add multiple constraints. It can be intermixed with calls to <code>transform()</code> and <code>castTo()</code>.</p>
<h2><a class="anchor" id="autotoc_md1303"></a>
Transformation: transform()</h2>
<p>Successfully validated data can be modified using a custom function:</p>
<div class="fragment"><div class="line"><span class="comment">// conversion to uppercase:</span></div>
<div class="line">Expect::string()-&gt;transform(fn(<span class="keywordtype">string</span> $s) =&gt; strtoupper($s));</div>
</div><!-- fragment --><p>The method can be called repeatedly to add multiple transformations. It can be intermixed with calls to <code>assert()</code> and <code>castTo()</code>. The operations will be executed in the order in which they are declared:</p>
<div class="fragment"><div class="line">Expect::type(<span class="stringliteral">&#39;string|int&#39;</span>)</div>
<div class="line">    -&gt;castTo(<span class="stringliteral">&#39;string&#39;</span>)</div>
<div class="line">    -&gt;assert(<span class="stringliteral">&#39;ctype_lower&#39;</span>, <span class="stringliteral">&#39;All characters must be lowercased&#39;</span>)</div>
<div class="line">    -&gt;transform(fn(<span class="keywordtype">string</span> $s) =&gt; strtoupper($s)); <span class="comment">// conversion to uppercase</span></div>
</div><!-- fragment --><p>The <code>transform()</code> method can both transform and validate the value simultaneously. This is often simpler and less redundant than chaining <code>transform()</code> and <code>assert()</code>. For this purpose, the function receives a <a href="https://api.nette.org/schema/master/Nette/Schema/Context.html">Nette\Schema\Context</a> object with an <code>addError()</code> method, which can be used to add information about validation issues:</p>
<div class="fragment"><div class="line">Expect::string()</div>
<div class="line">    -&gt;transform(<span class="keyword">function</span> (<span class="keywordtype">string</span> $s, <a class="code hl_namespace" href="namespace_nette.html">Nette</a>\Schema\Context $context) {</div>
<div class="line">        <span class="keywordflow">if</span> (!ctype_lower($s)) {</div>
<div class="line">            $context-&gt;addError(<span class="stringliteral">&#39;All characters must be lowercased&#39;</span>, <span class="stringliteral">&#39;my.case.error&#39;</span>);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">null</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> strtoupper($s);</div>
<div class="line">    });</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1304"></a>
Casting: castTo()</h2>
<p>Successfully validated data can be cast:</p>
<div class="fragment"><div class="line">Expect::scalar()-&gt;castTo(<span class="stringliteral">&#39;string&#39;</span>);</div>
</div><!-- fragment --><p>In addition to native PHP types, you can also cast to classes. It distinguishes whether it is a simple class without a constructor or a class with a constructor. If the class has no constructor, an instance of it is created and all elements of the structure are written to its properties:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Info</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">bool</span> $processRefund;</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">int</span> $refundAmount;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Expect::structure([</div>
<div class="line">    <span class="stringliteral">&#39;processRefund&#39;</span> =&gt; Expect::bool(),</div>
<div class="line">    <span class="stringliteral">&#39;refundAmount&#39;</span> =&gt; Expect::int(),</div>
<div class="line">])-&gt;castTo(Info::class);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// creates &#39;$obj = new Info&#39; and writes to $obj-&gt;processRefund and $obj-&gt;refundAmount</span></div>
</div><!-- fragment --><p>If the class has a constructor, the elements of the structure are passed as named parameters to the constructor (requires PHP 8):</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Info</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">function</span> __construct(</div>
<div class="line">        <span class="keyword">public</span> <span class="keywordtype">bool</span> $processRefund,</div>
<div class="line">        <span class="keyword">public</span> <span class="keywordtype">int</span> $refundAmount,</div>
<div class="line">    ) {</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// creates $obj = new Info(processRefund: ..., refundAmount: ...)</span></div>
</div><!-- fragment --><p>Casting combined with a scalar parameter creates an object and passes the value as the sole parameter to the constructor:</p>
<div class="fragment"><div class="line">Expect::string()-&gt;castTo(DateTime::class);</div>
<div class="line"><span class="comment">// creates new DateTime(...)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1305"></a>
Normalization: before()</h2>
<p>Prior to the validation itself, the data can be normalized using the method <code>before()</code>. As an example, let's have an element that must be an array of strings (eg &lsquo;['a&rsquo;, 'b', 'c']<code>), but receives input in the form of a string</code>a b c`:</p>
<div class="fragment"><div class="line">$explode = fn($v) =&gt; explode(<span class="charliteral">&#39; &#39;</span>, $v);</div>
<div class="line"> </div>
<div class="line">$schema = Expect::arrayOf(<span class="stringliteral">&#39;string&#39;</span>)</div>
<div class="line">    -&gt;before($explode);</div>
<div class="line"> </div>
<div class="line">$normalized = $processor-&gt;process($schema, <span class="stringliteral">&#39;a b c&#39;</span>);</div>
<div class="line"><span class="comment">// OK, returns [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1306"></a>
Mapping to Objects: from()</h2>
<p>You can generate structure schema from the class. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Config</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> $name;</div>
<div class="line">    <span class="keyword">public</span> $password;</div>
<div class="line">    <span class="keyword">public</span> $admin = <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">$schema = Expect::from(<span class="keyword">new</span> Config);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_variable" href="update__mime__types_8php.html#ab9807831e7f54cb17039eb0b280ef902">$data</a> = [</div>
<div class="line">    <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;jeff&#39;</span>,</div>
<div class="line">];</div>
<div class="line"> </div>
<div class="line">$normalized = $processor-&gt;process($schema, <a class="code hl_variable" href="update__mime__types_8php.html#ab9807831e7f54cb17039eb0b280ef902">$data</a>);</div>
<div class="line"><span class="comment">// $normalized instanceof Config</span></div>
<div class="line"><span class="comment">// $normalized = {&#39;name&#39; =&gt; &#39;jeff&#39;, &#39;password&#39; =&gt; null, &#39;admin&#39; =&gt; false}</span></div>
</div><!-- fragment --><p>If you are using PHP 7.4 or higher, you can use native types:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Config</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">string</span> $name;</div>
<div class="line">    <span class="keyword">public</span> ?<span class="keywordtype">string</span> $password;</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">bool</span> $admin = <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">$schema = Expect::from(<span class="keyword">new</span> Config);</div>
</div><!-- fragment --><p>Anonymous classes are also supported:</p>
<div class="fragment"><div class="line">$schema = Expect::from(<span class="keyword">new</span> <span class="keyword">class</span> {</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">string</span> $name;</div>
<div class="line">    <span class="keyword">public</span> ?<span class="keywordtype">string</span> $password;</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">bool</span> $admin = <span class="keyword">false</span>;</div>
<div class="line">});</div>
</div><!-- fragment --><p>Because the information obtained from the class definition may not be sufficient, you can add a custom schema for the elements with the second parameter:</p>
<div class="fragment"><div class="line">$schema = Expect::from(<span class="keyword">new</span> Config, [</div>
<div class="line">    <span class="stringliteral">&#39;name&#39;</span> =&gt; Expect::string()-&gt;pattern(<span class="stringliteral">&#39;\w:.*&#39;</span>),</div>
<div class="line">]);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
