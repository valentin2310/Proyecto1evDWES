<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Proyecto1ev: Guzzle Promises</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="favicon.ico"/></td>
  <td id="projectalign">
   <div id="projectname">Proyecto1ev<span id="projectnumber">&#160;1</span>
   </div>
   <div id="projectbrief">Proyecto 1ยบ evaluacion, Laravel</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Guzzle Promises</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md543"></a> <a href="https://promisesaplus.com/">Promises/A+</a> implementation that handles promise chaining and resolution iteratively, allowing for "infinite" promise chaining while keeping the stack size constant. Read <a href="https://blog.domenic.me/youre-missing-the-point-of-promises/">this blog post</a> for a general introduction to promises.</p>
<ul>
<li>Features</li>
<li>Quick start</li>
<li>Synchronous wait</li>
<li>Cancellation</li>
<li>API<ul>
<li>Promise</li>
<li>FulfilledPromise</li>
<li>RejectedPromise</li>
</ul>
</li>
<li>Promise interop</li>
<li>Implementation notes</li>
</ul>
<h1><a class="anchor" id="autotoc_md544"></a>
Features</h1>
<ul>
<li><a href="https://promisesaplus.com/">Promises/A+</a> implementation.</li>
<li>Promise resolution and chaining is handled iteratively, allowing for "infinite" promise chaining.</li>
<li>Promises have a synchronous <code>wait</code> method.</li>
<li>Promises can be cancelled.</li>
<li>Works with any object that has a <code>then</code> function.</li>
<li>C# style async/await coroutine promises using <code><a class="el" href="namespace_guzzle_http.html">GuzzleHttp</a>\Promise\Coroutine::of()</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md545"></a>
Installation</h1>
<div class="fragment"><div class="line">composer require guzzlehttp/promises</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md546"></a>
Version Guidance</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Version   </th><th class="markdownTableHeadNone">Status   </th><th class="markdownTableHeadNone">PHP Version    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1.x   </td><td class="markdownTableBodyNone">Bug and security fixes   </td><td class="markdownTableBodyNone">&gt;=5.5,&lt;8.3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2.x   </td><td class="markdownTableBodyNone">Latest   </td><td class="markdownTableBodyNone">&gt;=7.2.5,&lt;8.4   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md547"></a>
Quick Start</h1>
<p>A <em>promise</em> represents the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its <code>then</code> method, which registers callbacks to receive either a promise's eventual value or the reason why the promise cannot be fulfilled.</p>
<h2><a class="anchor" id="autotoc_md548"></a>
Callbacks</h2>
<p>Callbacks are registered with the <code>then</code> method by providing an optional <code>$onFulfilled</code> followed by an optional <code>$onRejected</code> function.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise-&gt;then(</div>
<div class="line">    <span class="comment">// $onFulfilled</span></div>
<div class="line">    <span class="keyword">function</span> ($value) {</div>
<div class="line">        echo <span class="stringliteral">&#39;The promise was fulfilled.&#39;</span>;</div>
<div class="line">    },</div>
<div class="line">    <span class="comment">// $onRejected</span></div>
<div class="line">    <span class="keyword">function</span> ($reason) {</div>
<div class="line">        echo <span class="stringliteral">&#39;The promise was rejected.&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="ttc" id="aclass_guzzle_http_1_1_promise_1_1_promise_html"><div class="ttname"><a href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a></div><div class="ttdef"><b>Definition</b> <a href="_promise_8php_source.html#l00014">Promise.php:15</a></div></div>
</div><!-- fragment --><p><em>Resolving</em> a promise means that you either fulfill a promise with a <em>value</em> or reject a promise with a <em>reason</em>. Resolving a promise triggers callbacks registered with the promise's <code>then</code> method. These callbacks are triggered only once and in the order in which they were added.</p>
<h2><a class="anchor" id="autotoc_md549"></a>
Resolving a Promise</h2>
<p>Promises are fulfilled using the <code>resolve($value)</code> method. Resolving a promise with any value other than a <code><a class="el" href="namespace_guzzle_http.html">GuzzleHttp</a>\Promise\RejectedPromise</code> will trigger all of the onFulfilled callbacks (resolving a promise with a rejected promise will reject the promise and trigger the <code>$onRejected</code> callbacks).</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise</div>
<div class="line">    -&gt;then(<span class="keyword">function</span> ($value) {</div>
<div class="line">        <span class="comment">// Return a value and don&#39;t break the chain</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Hello, &quot;</span> . $value;</div>
<div class="line">    })</div>
<div class="line">    <span class="comment">// This then is executed after the first then and receives the value</span></div>
<div class="line">    <span class="comment">// returned from the first then.</span></div>
<div class="line">    -&gt;then(<span class="keyword">function</span> ($value) {</div>
<div class="line">        echo $value;</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Resolving the promise triggers the $onFulfilled callbacks and outputs</span></div>
<div class="line"><span class="comment">// &quot;Hello, reader.&quot;</span></div>
<div class="line">$promise-&gt;resolve(<span class="stringliteral">&#39;reader.&#39;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md550"></a>
Promise Forwarding</h2>
<p>Promises can be chained one after the other. Each then in the chain is a new promise. The return value of a promise is what's forwarded to the next promise in the chain. Returning a promise in a <code>then</code> callback will cause the subsequent promises in the chain to only be fulfilled when the returned promise has been fulfilled. The next promise in the chain will be invoked with the resolved value of the promise.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$nextPromise = <span class="keyword">new</span> Promise();</div>
<div class="line"> </div>
<div class="line">$promise</div>
<div class="line">    -&gt;then(<span class="keyword">function</span> ($value) use ($nextPromise) {</div>
<div class="line">        echo $value;</div>
<div class="line">        <span class="keywordflow">return</span> $nextPromise;</div>
<div class="line">    })</div>
<div class="line">    -&gt;then(<span class="keyword">function</span> ($value) {</div>
<div class="line">        echo $value;</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Triggers the first callback and outputs &quot;A&quot;</span></div>
<div class="line">$promise-&gt;resolve(<span class="charliteral">&#39;A&#39;</span>);</div>
<div class="line"><span class="comment">// Triggers the second callback and outputs &quot;B&quot;</span></div>
<div class="line">$nextPromise-&gt;resolve(<span class="charliteral">&#39;B&#39;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md551"></a>
Promise Rejection</h2>
<p>When a promise is rejected, the <code>$onRejected</code> callbacks are invoked with the rejection reason.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise-&gt;then(<span class="keyword">null</span>, <span class="keyword">function</span> ($reason) {</div>
<div class="line">    echo $reason;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">$promise-&gt;reject(<span class="stringliteral">&#39;Error!&#39;</span>);</div>
<div class="line"><span class="comment">// Outputs &quot;Error!&quot;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md552"></a>
Rejection Forwarding</h2>
<p>If an exception is thrown in an <code>$onRejected</code> callback, subsequent <code>$onRejected</code> callbacks are invoked with the thrown exception as the reason.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise-&gt;then(<span class="keyword">null</span>, <span class="keyword">function</span> ($reason) {</div>
<div class="line">    <span class="keywordflow">throw</span> <span class="keyword">new</span> Exception($reason);</div>
<div class="line">})-&gt;then(<span class="keyword">null</span>, <span class="keyword">function</span> ($reason) {</div>
<div class="line">    assert($reason-&gt;getMessage() === <span class="stringliteral">&#39;Error!&#39;</span>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">$promise-&gt;reject(<span class="stringliteral">&#39;Error!&#39;</span>);</div>
</div><!-- fragment --><p>You can also forward a rejection down the promise chain by returning a <code><a class="el" href="namespace_guzzle_http.html">GuzzleHttp</a>\Promise\RejectedPromise</code> in either an <code>$onFulfilled</code> or <code>$onRejected</code> callback.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_rejected_promise.html">GuzzleHttp\Promise\RejectedPromise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise-&gt;then(<span class="keyword">null</span>, <span class="keyword">function</span> ($reason) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> RejectedPromise($reason);</div>
<div class="line">})-&gt;then(<span class="keyword">null</span>, <span class="keyword">function</span> ($reason) {</div>
<div class="line">    assert($reason === <span class="stringliteral">&#39;Error!&#39;</span>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">$promise-&gt;reject(<span class="stringliteral">&#39;Error!&#39;</span>);</div>
<div class="ttc" id="aclass_guzzle_http_1_1_promise_1_1_rejected_promise_html"><div class="ttname"><a href="class_guzzle_http_1_1_promise_1_1_rejected_promise.html">GuzzleHttp\Promise\RejectedPromise</a></div><div class="ttdef"><b>Definition</b> <a href="_rejected_promise_8php_source.html#l00015">RejectedPromise.php:16</a></div></div>
</div><!-- fragment --><p>If an exception is not thrown in a <code>$onRejected</code> callback and the callback does not return a rejected promise, downstream <code>$onFulfilled</code> callbacks are invoked using the value returned from the <code>$onRejected</code> callback.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise</div>
<div class="line">    -&gt;then(<span class="keyword">null</span>, <span class="keyword">function</span> ($reason) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;It&#39;s ok&quot;</span>;</div>
<div class="line">    })</div>
<div class="line">    -&gt;then(<span class="keyword">function</span> ($value) {</div>
<div class="line">        assert($value === <span class="stringliteral">&quot;It&#39;s ok&quot;</span>);</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">$promise-&gt;reject(<span class="stringliteral">&#39;Error!&#39;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md553"></a>
Synchronous Wait</h1>
<p>You can synchronously force promises to complete using a promise's <code>wait</code> method. When creating a promise, you can provide a wait function that is used to synchronously force a promise to complete. When a wait function is invoked it is expected to deliver a value to the promise or reject the promise. If the wait function does not deliver a value, then an exception is thrown. The wait function provided to a promise constructor is invoked when the <code>wait</code> function of the promise is called.</p>
<div class="fragment"><div class="line">$promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> () use (&amp;$promise) {</div>
<div class="line">    $promise-&gt;resolve(<span class="stringliteral">&#39;foo&#39;</span>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Calling wait will return the value of the promise.</span></div>
<div class="line">echo $promise-&gt;wait(); <span class="comment">// outputs &quot;foo&quot;</span></div>
</div><!-- fragment --><p>If an exception is encountered while invoking the wait function of a promise, the promise is rejected with the exception and the exception is thrown.</p>
<div class="fragment"><div class="line">$promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> () use (&amp;$promise) {</div>
<div class="line">    <span class="keywordflow">throw</span> <span class="keyword">new</span> Exception(<span class="stringliteral">&#39;foo&#39;</span>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">$promise-&gt;wait(); <span class="comment">// throws the exception.</span></div>
</div><!-- fragment --><p>Calling <code>wait</code> on a promise that has been fulfilled will not trigger the wait function. It will simply return the previously resolved value.</p>
<div class="fragment"><div class="line">$promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> () { die(<span class="stringliteral">&#39;this is not called!&#39;</span>); });</div>
<div class="line">$promise-&gt;resolve(<span class="stringliteral">&#39;foo&#39;</span>);</div>
<div class="line">echo $promise-&gt;wait(); <span class="comment">// outputs &quot;foo&quot;</span></div>
</div><!-- fragment --><p>Calling <code>wait</code> on a promise that has been rejected will throw an exception. If the rejection reason is an instance of <code>\Exception</code> the reason is thrown. Otherwise, a <code><a class="el" href="namespace_guzzle_http.html">GuzzleHttp</a>\Promise\RejectionException</code> is thrown and the reason can be obtained by calling the <code>getReason</code> method of the exception.</p>
<div class="fragment"><div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise-&gt;reject(<span class="stringliteral">&#39;foo&#39;</span>);</div>
<div class="line">$promise-&gt;wait();</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;PHP Fatal error: Uncaught exception '<a class="el" href="namespace_guzzle_http.html">GuzzleHttp</a>\Promise\RejectionException' with message 'The promise was rejected with value: foo' </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md554"></a>
Unwrapping a Promise</h2>
<p>When synchronously waiting on a promise, you are joining the state of the promise into the current state of execution (i.e., return the value of the promise if it was fulfilled or throw an exception if it was rejected). This is called "unwrapping" the promise. Waiting on a promise will by default unwrap the promise state.</p>
<p>You can force a promise to resolve and <em>not</em> unwrap the state of the promise by passing <code>false</code> to the first argument of the <code>wait</code> function:</p>
<div class="fragment"><div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise-&gt;reject(<span class="stringliteral">&#39;foo&#39;</span>);</div>
<div class="line"><span class="comment">// This will not throw an exception. It simply ensures the promise has</span></div>
<div class="line"><span class="comment">// been resolved.</span></div>
<div class="line">$promise-&gt;wait(<span class="keyword">false</span>);</div>
</div><!-- fragment --><p>When unwrapping a promise, the resolved value of the promise will be waited upon until the unwrapped value is not a promise. This means that if you resolve promise A with a promise B and unwrap promise A, the value returned by the wait function will be the value delivered to promise B.</p>
<p><b>Note</b>: when you do not unwrap the promise, no value is returned.</p>
<h1><a class="anchor" id="autotoc_md555"></a>
Cancellation</h1>
<p>You can cancel a promise that has not yet been fulfilled using the <code>cancel()</code> method of a promise. When creating a promise you can provide an optional cancel function that when invoked cancels the action of computing a resolution of the promise.</p>
<h1><a class="anchor" id="autotoc_md556"></a>
API</h1>
<h2><a class="anchor" id="autotoc_md557"></a>
Promise</h2>
<p>When creating a promise object, you can provide an optional <code>$waitFn</code> and <code>$cancelFn</code>. <code>$waitFn</code> is a function that is invoked with no arguments and is expected to resolve the promise. <code>$cancelFn</code> is a function with no arguments that is expected to cancel the computation of a promise. It is invoked when the <code>cancel()</code> method of a promise is called.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise(</div>
<div class="line">    <span class="keyword">function</span> () use (&amp;$promise) {</div>
<div class="line">        $promise-&gt;resolve(<span class="stringliteral">&#39;waited&#39;</span>);</div>
<div class="line">    },</div>
<div class="line">    <span class="keyword">function</span> () {</div>
<div class="line">        <span class="comment">// do something that will cancel the promise computation (e.g., close</span></div>
<div class="line">        <span class="comment">// a socket, cancel a database query, etc...)</span></div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespace_nette_1_1_schema_1_1_elements.html#a574093ac856447ce4d3781e2bd8beda5">assert</a>(<span class="stringliteral">&#39;waited&#39;</span> === $promise-&gt;wait());</div>
<div class="ttc" id="anamespace_nette_1_1_schema_1_1_elements_html_a574093ac856447ce4d3781e2bd8beda5"><div class="ttname"><a href="namespace_nette_1_1_schema_1_1_elements.html#a574093ac856447ce4d3781e2bd8beda5">Nette\Schema\Elements\assert</a></div><div class="ttdeci">assert(callable $handler, ?string $description=null)</div><div class="ttdef"><b>Definition</b> <a href="nette_2schema_2src_2_schema_2_elements_2_base_8php_source.html#l00072">Base.php:72</a></div></div>
</div><!-- fragment --><p>A promise has the following methods:</p>
<ul>
<li><p class="startli"><code>then(callable $onFulfilled, callable $onRejected) : PromiseInterface</code></p>
<p class="startli">Appends fulfillment and rejection handlers to the promise, and returns a new promise resolving to the return value of the called handler.</p>
</li>
<li><p class="startli"><code>otherwise(callable $onRejected) : PromiseInterface</code></p>
<p class="startli">Appends a rejection handler callback to the promise, and returns a new promise resolving to the return value of the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled.</p>
</li>
<li><p class="startli"><code>wait($unwrap = true) : mixed</code></p>
<p class="startli">Synchronously waits on the promise to complete.</p>
<p class="startli"><code>$unwrap</code> controls whether or not the value of the promise is returned for a fulfilled promise or if an exception is thrown if the promise is rejected. This is set to <code>true</code> by default.</p>
</li>
<li><p class="startli"><code>cancel()</code></p>
<p class="startli">Attempts to cancel the promise if possible. The promise being cancelled and the parent most ancestor that has not yet been resolved will also be cancelled. Any promises waiting on the cancelled promise to resolve will also be cancelled.</p>
</li>
<li><p class="startli"><code>getState() : string</code></p>
<p class="startli">Returns the state of the promise. One of <code>pending</code>, <code>fulfilled</code>, or <code>rejected</code>.</p>
</li>
<li><p class="startli"><code>resolve($value)</code></p>
<p class="startli">Fulfills the promise with the given <code>$value</code>.</p>
</li>
<li><p class="startli"><code>reject($reason)</code></p>
<p class="startli">Rejects the promise with the given <code>$reason</code>.</p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md558"></a>
FulfilledPromise</h2>
<p>A fulfilled promise can be created to represent a promise that has been fulfilled.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_fulfilled_promise.html">GuzzleHttp\Promise\FulfilledPromise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> FulfilledPromise(<span class="stringliteral">&#39;value&#39;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fulfilled callbacks are immediately invoked.</span></div>
<div class="line">$promise-&gt;then(<span class="keyword">function</span> ($value) {</div>
<div class="line">    echo $value;</div>
<div class="line">});</div>
<div class="ttc" id="aclass_guzzle_http_1_1_promise_1_1_fulfilled_promise_html"><div class="ttname"><a href="class_guzzle_http_1_1_promise_1_1_fulfilled_promise.html">GuzzleHttp\Promise\FulfilledPromise</a></div><div class="ttdef"><b>Definition</b> <a href="_fulfilled_promise_8php_source.html#l00015">FulfilledPromise.php:16</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md559"></a>
RejectedPromise</h2>
<p>A rejected promise can be created to represent a promise that has been rejected.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_rejected_promise.html">GuzzleHttp\Promise\RejectedPromise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> RejectedPromise(<span class="stringliteral">&#39;Error&#39;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Rejected callbacks are immediately invoked.</span></div>
<div class="line">$promise-&gt;then(<span class="keyword">null</span>, <span class="keyword">function</span> ($reason) {</div>
<div class="line">    echo $reason;</div>
<div class="line">});</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md560"></a>
Promise Interoperability</h1>
<p>This library works with foreign promises that have a <code>then</code> method. This means you can use Guzzle promises with <a href="https://github.com/reactphp/promise">React promises</a> for example. When a foreign promise is returned inside of a then method callback, promise resolution will occur recursively.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a React promise</span></div>
<div class="line">$deferred = <span class="keyword">new</span> React\Promise\Deferred();</div>
<div class="line">$reactPromise = $deferred-&gt;promise();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a Guzzle promise that is fulfilled with a React promise.</span></div>
<div class="line">$guzzlePromise = <span class="keyword">new</span> <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>();</div>
<div class="line">$guzzlePromise-&gt;then(<span class="keyword">function</span> ($value) use ($reactPromise) {</div>
<div class="line">    <span class="comment">// Do something something with the value...</span></div>
<div class="line">    <span class="comment">// Return the React promise</span></div>
<div class="line">    <span class="keywordflow">return</span> $reactPromise;</div>
<div class="line">});</div>
</div><!-- fragment --><p>Please note that wait and cancel chaining is no longer possible when forwarding a foreign promise. You will need to wrap a third-party promise with a Guzzle promise in order to utilize wait and cancel functions with foreign promises.</p>
<h2><a class="anchor" id="autotoc_md561"></a>
Event Loop Integration</h2>
<p>In order to keep the stack size constant, Guzzle promises are resolved asynchronously using a task queue. When waiting on promises synchronously, the task queue will be automatically run to ensure that the blocking promise and any forwarded promises are resolved. When using promises asynchronously in an event loop, you will need to run the task queue on each tick of the loop. If you do not run the task queue, then promises will not be resolved.</p>
<p>You can run the task queue using the <code>run()</code> method of the global task queue instance.</p>
<div class="fragment"><div class="line"><span class="comment">// Get the global task queue</span></div>
<div class="line">$queue = GuzzleHttp\Promise\Utils::queue();</div>
<div class="line">$queue-&gt;run();</div>
</div><!-- fragment --><p>For example, you could use Guzzle promises with React using a periodic timer:</p>
<div class="fragment"><div class="line"><a class="code hl_variable" href="1a557177cfd75ac38db8e3e496f560d8_8php.html#ae7d53f6b57a5cd2cec9cadec7e80910a">$loop</a> = React\EventLoop\Factory::create();</div>
<div class="line"><a class="code hl_variable" href="1a557177cfd75ac38db8e3e496f560d8_8php.html#ae7d53f6b57a5cd2cec9cadec7e80910a">$loop</a>-&gt;addPeriodicTimer(0, [$queue, <span class="stringliteral">&#39;run&#39;</span>]);</div>
<div class="ttc" id="a1a557177cfd75ac38db8e3e496f560d8_8php_html_ae7d53f6b57a5cd2cec9cadec7e80910a"><div class="ttname"><a href="1a557177cfd75ac38db8e3e496f560d8_8php.html#ae7d53f6b57a5cd2cec9cadec7e80910a">$loop</a></div><div class="ttdeci">$loop</div><div class="ttdef"><b>Definition</b> <a href="1a557177cfd75ac38db8e3e496f560d8_8php_source.html#l00130">1a557177cfd75ac38db8e3e496f560d8.php:130</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md562"></a>
Implementation Notes</h1>
<h2><a class="anchor" id="autotoc_md563"></a>
Promise Resolution and Chaining is Handled Iteratively</h2>
<p>By shuffling pending handlers from one owner to another, promises are resolved iteratively, allowing for "infinite" then chaining.</p>
<div class="fragment"><div class="line">&lt;?php</div>
<div class="line">require <span class="stringliteral">&#39;vendor/autoload.php&#39;</span>;</div>
<div class="line"> </div>
<div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$parent = <span class="keyword">new</span> Promise();</div>
<div class="line">$p = $parent;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> ($i = 0; $i &lt; 1000; $i++) {</div>
<div class="line">    $p = $p-&gt;then(<span class="keyword">function</span> ($v) {</div>
<div class="line">        <span class="comment">// The stack size remains constant (a good thing)</span></div>
<div class="line">        echo xdebug_get_stack_depth() . <span class="stringliteral">&#39;, &#39;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> $v + 1;</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">$parent-&gt;resolve(0);</div>
<div class="line">var_dump($p-&gt;wait()); <span class="comment">// int(1000)</span></div>
</div><!-- fragment --><p>When a promise is fulfilled or rejected with a non-promise value, the promise then takes ownership of the handlers of each child promise and delivers values down the chain without using recursion.</p>
<p>When a promise is resolved with another promise, the original promise transfers all of its pending handlers to the new promise. When the new promise is eventually resolved, all of the pending handlers are delivered the forwarded value.</p>
<h2><a class="anchor" id="autotoc_md564"></a>
A Promise is the Deferred</h2>
<p>Some promise libraries implement promises using a deferred object to represent a computation and a promise object to represent the delivery of the result of the computation. This is a nice separation of computation and delivery because consumers of the promise cannot modify the value that will be eventually delivered.</p>
<p>One side effect of being able to implement promise resolution and chaining iteratively is that you need to be able for one promise to reach into the state of another promise to shuffle around ownership of handlers. In order to achieve this without making the handlers of a promise publicly mutable, a promise is also the deferred value, allowing promises of the same parent class to reach into and modify the private properties of promises of the same type. While this does allow consumers of the value to modify the resolution or rejection of the deferred, it is a small price to pay for keeping the stack size constant.</p>
<div class="fragment"><div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise-&gt;then(<span class="keyword">function</span> ($value) { echo $value; });</div>
<div class="line"><span class="comment">// The promise is the deferred value, so you can deliver a value to it.</span></div>
<div class="line">$promise-&gt;resolve(<span class="stringliteral">&#39;foo&#39;</span>);</div>
<div class="line"><span class="comment">// prints &quot;foo&quot;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md565"></a>
Upgrading from Function API</h1>
<p>A static API was first introduced in 1.4.0, in order to mitigate problems with functions conflicting between global and local copies of the package. The function API was removed in 2.0.0. A migration table has been provided here for your convenience:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Original Function   </th><th class="markdownTableHeadNone">Replacement Method    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>queue</code>   </td><td class="markdownTableBodyNone"><code>Utils::queue</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>task</code>   </td><td class="markdownTableBodyNone"><code>Utils::task</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>promise_for</code>   </td><td class="markdownTableBodyNone"><code>Create::promiseFor</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>rejection_for</code>   </td><td class="markdownTableBodyNone"><code>Create::rejectionFor</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>exception_for</code>   </td><td class="markdownTableBodyNone"><code>Create::exceptionFor</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>iter_for</code>   </td><td class="markdownTableBodyNone"><code>Create::iterFor</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>inspect</code>   </td><td class="markdownTableBodyNone"><code>Utils::inspect</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>inspect_all</code>   </td><td class="markdownTableBodyNone"><code>Utils::inspectAll</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>unwrap</code>   </td><td class="markdownTableBodyNone"><code>Utils::unwrap</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>all</code>   </td><td class="markdownTableBodyNone"><code>Utils::all</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>some</code>   </td><td class="markdownTableBodyNone"><code>Utils::some</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>any</code>   </td><td class="markdownTableBodyNone"><code>Utils::any</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>settle</code>   </td><td class="markdownTableBodyNone"><code>Utils::settle</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>each</code>   </td><td class="markdownTableBodyNone"><code>Each::of</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>each_limit</code>   </td><td class="markdownTableBodyNone"><code>Each::ofLimit</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>each_limit_all</code>   </td><td class="markdownTableBodyNone"><code>Each::ofLimitAll</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>!is_fulfilled</code>   </td><td class="markdownTableBodyNone"><code>Is::pending</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>is_fulfilled</code>   </td><td class="markdownTableBodyNone"><code>Is::fulfilled</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>is_rejected</code>   </td><td class="markdownTableBodyNone"><code>Is::rejected</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>is_settled</code>   </td><td class="markdownTableBodyNone"><code>Is::settled</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>coroutine</code>   </td><td class="markdownTableBodyNone"><code>Coroutine::of</code>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md566"></a>
Security</h1>
<p>If you discover a security vulnerability within this package, please send an email to <a href="#" onclick="location.href='mai'+'lto:'+'sec'+'ur'+'ity'+'@t'+'ide'+'li'+'ft.'+'co'+'m'; return false;">secur<span class="obfuscator">.nosp@m.</span>ity@<span class="obfuscator">.nosp@m.</span>tidel<span class="obfuscator">.nosp@m.</span>ift.<span class="obfuscator">.nosp@m.</span>com</a>. All security vulnerabilities will be promptly addressed. Please do not disclose security-related issues publicly until a fix has been announced. Please see <a href="https://github.com/guzzle/promises/security/policy">Security Policy</a> for more information.</p>
<h1><a class="anchor" id="autotoc_md567"></a>
License</h1>
<p>Guzzle is made available under the MIT License (MIT). Please see [License File](LICENSE) for more information.</p>
<h1><a class="anchor" id="autotoc_md568"></a>
For Enterprise</h1>
<p>Available as part of the Tidelift Subscription</p>
<p>The maintainers of Guzzle and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. <a href="https://tidelift.com/subscription/pkg/packagist-guzzlehttp-promises?utm_source=packagist-guzzlehttp-promises&amp;utm_medium=referral&amp;utm_campaign=enterprise&amp;utm_term=repo">Learn more.</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
