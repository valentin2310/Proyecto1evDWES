\chapter{PSR-\/7 Message Implementation}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e}{}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e}\index{PSR-\/7 Message Implementation@{PSR-\/7 Message Implementation}}
\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md663}%
\Hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md663}%
 This repository contains a full \href{https://www.php-fig.org/psr/psr-7/}{\texttt{ PSR-\/7}} message implementation, several stream decorators, and some helpful functionality like query string parsing.

 \hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md664}{}\doxysection{\texorpdfstring{Features}{Features}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md664}
This package comes with a number of stream implementations and stream decorators.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md665}{}\doxysection{\texorpdfstring{Installation}{Installation}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md665}

\begin{DoxyCode}{0}
\DoxyCodeLine{composer\ require\ guzzlehttp/psr7}

\end{DoxyCode}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md666}{}\doxysection{\texorpdfstring{Version Guidance}{Version Guidance}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md666}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Version   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Status   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ PHP Version    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Version   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Status   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ PHP Version    }\\\cline{1-3}
\endhead
1.\+x   &Security fixes only   &\texorpdfstring{$>$}{>}=5.\+4,\texorpdfstring{$<$}{<}8.\+1    \\\cline{1-3}
2.\+x   &Latest   &\texorpdfstring{$>$}{>}=7.\+2.\+5,\texorpdfstring{$<$}{<}8.\+4   \\\cline{1-3}
\end{longtabu}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md667}{}\doxysection{\texorpdfstring{Append\+Stream}{AppendStream}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md667}
{\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Append\+Stream}

Reads from multiple streams, one after the other.


\begin{DoxyCode}{0}
\DoxyCodeLine{use\ \mbox{\hyperlink{namespace_guzzle_http_1_1_psr7}{GuzzleHttp\(\backslash\)Psr7}};}
\DoxyCodeLine{}
\DoxyCodeLine{\$a\ =\ Psr7\(\backslash\)Utils::streamFor(\textcolor{stringliteral}{'abc,\ '});}
\DoxyCodeLine{\$b\ =\ Psr7\(\backslash\)Utils::streamFor(\textcolor{stringliteral}{'123.'});}
\DoxyCodeLine{\$composed\ =\ \textcolor{keyword}{new}\ Psr7\(\backslash\)AppendStream([\$a,\ \$b]);}
\DoxyCodeLine{}
\DoxyCodeLine{\$composed-\/>addStream(Psr7\(\backslash\)Utils::streamFor(\textcolor{stringliteral}{'\ Above\ all\ listen\ to\ me'}));}
\DoxyCodeLine{}
\DoxyCodeLine{echo\ \$composed;\ \textcolor{comment}{//\ abc,\ 123.\ Above\ all\ listen\ to\ me.}}

\end{DoxyCode}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md668}{}\doxysection{\texorpdfstring{Buffer\+Stream}{BufferStream}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md668}
{\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Buffer\+Stream}

Provides a buffer stream that can be written to fill a buffer, and read from to remove bytes from the buffer.

This stream returns a "{}hwm"{} metadata value that tells upstream consumers what the configured high water mark of the stream is, or the maximum preferred size of the buffer.


\begin{DoxyCode}{0}
\DoxyCodeLine{use\ \mbox{\hyperlink{namespace_guzzle_http_1_1_psr7}{GuzzleHttp\(\backslash\)Psr7}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ When\ more\ than\ 1024\ bytes\ are\ in\ the\ buffer,\ it\ will\ begin\ returning}}
\DoxyCodeLine{\textcolor{comment}{//\ false\ to\ writes.\ This\ is\ an\ indication\ that\ writers\ should\ slow\ down.}}
\DoxyCodeLine{\$buffer\ =\ \textcolor{keyword}{new}\ Psr7\(\backslash\)BufferStream(1024);}

\end{DoxyCode}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md669}{}\doxysection{\texorpdfstring{Caching\+Stream}{CachingStream}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md669}
The Caching\+Stream is used to allow seeking over previously read bytes on non-\/seekable streams. This can be useful when transferring a non-\/seekable entity body fails due to needing to rewind the stream (for example, resulting from a redirect). Data that is read from the remote stream will be buffered in a PHP temp stream so that previously read bytes are cached first in memory, then on disk.


\begin{DoxyCode}{0}
\DoxyCodeLine{use\ \mbox{\hyperlink{namespace_guzzle_http_1_1_psr7}{GuzzleHttp\(\backslash\)Psr7}};}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{namespace_illuminate_1_1_database_1_1_eloquent_1_1_concerns_aaf21c024e741a75af29e50e0046db8b3}{\$original}}\ =\ Psr7\(\backslash\)Utils::streamFor(fopen(\textcolor{stringliteral}{'http://www.google.com'},\ \textcolor{charliteral}{'r'}));}
\DoxyCodeLine{\$stream\ =\ \textcolor{keyword}{new}\ Psr7\(\backslash\)CachingStream(\$original);}
\DoxyCodeLine{}
\DoxyCodeLine{\$stream-\/>read(1024);}
\DoxyCodeLine{echo\ \$stream-\/>tell();}
\DoxyCodeLine{\textcolor{comment}{//\ 1024}}
\DoxyCodeLine{}
\DoxyCodeLine{\$stream-\/>seek(0);}
\DoxyCodeLine{echo\ \$stream-\/>tell();}
\DoxyCodeLine{\textcolor{comment}{//\ 0}}

\end{DoxyCode}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md670}{}\doxysection{\texorpdfstring{Dropping\+Stream}{DroppingStream}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md670}
{\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Dropping\+Stream}

Stream decorator that begins dropping data once the size of the underlying stream becomes too full.


\begin{DoxyCode}{0}
\DoxyCodeLine{use\ \mbox{\hyperlink{namespace_guzzle_http_1_1_psr7}{GuzzleHttp\(\backslash\)Psr7}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Create\ an\ empty\ stream}}
\DoxyCodeLine{\$stream\ =\ Psr7\(\backslash\)Utils::streamFor();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Start\ dropping\ data\ when\ the\ stream\ has\ more\ than\ 10\ bytes}}
\DoxyCodeLine{\$dropping\ =\ \textcolor{keyword}{new}\ Psr7\(\backslash\)DroppingStream(\$stream,\ 10);}
\DoxyCodeLine{}
\DoxyCodeLine{\$dropping-\/>write(\textcolor{stringliteral}{'01234567890123456789'});}
\DoxyCodeLine{echo\ \$stream;\ \textcolor{comment}{//\ 0123456789}}

\end{DoxyCode}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md671}{}\doxysection{\texorpdfstring{Fn\+Stream}{FnStream}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md671}
{\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Fn\+Stream}

Compose stream implementations based on a hash of functions.

Allows for easy testing and extension of a provided stream without needing to create a concrete class for a simple extension point.


\begin{DoxyCode}{0}
\DoxyCodeLine{use\ \mbox{\hyperlink{namespace_guzzle_http_1_1_psr7}{GuzzleHttp\(\backslash\)Psr7}};}
\DoxyCodeLine{}
\DoxyCodeLine{\$stream\ =\ Psr7\(\backslash\)Utils::streamFor(\textcolor{stringliteral}{'hi'});}
\DoxyCodeLine{\$fnStream\ =\ Psr7\(\backslash\)FnStream::decorate(\$stream,\ [}
\DoxyCodeLine{\ \ \ \ \textcolor{stringliteral}{'rewind'}\ =>\ \textcolor{keyword}{function}\ ()\ use\ (\$stream)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ echo\ \textcolor{stringliteral}{'About\ to\ rewind\ -\/\ '};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \$stream-\/>rewind();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ echo\ \textcolor{stringliteral}{'rewound!'};}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{]);}
\DoxyCodeLine{}
\DoxyCodeLine{\$fnStream-\/>rewind();}
\DoxyCodeLine{\textcolor{comment}{//\ Outputs:\ About\ to\ rewind\ -\/\ rewound!}}

\end{DoxyCode}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md672}{}\doxysection{\texorpdfstring{Inflate\+Stream}{InflateStream}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md672}
{\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Inflate\+Stream}

Uses PHP\textquotesingle{}s zlib.\+inflate filter to inflate zlib (HTTP deflate, RFC1950) or gzipped (RFC1952) content.

This stream decorator converts the provided stream to a PHP stream resource, then appends the zlib.\+inflate filter. The stream is then converted back to a Guzzle stream resource to be used as a Guzzle stream.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md673}{}\doxysection{\texorpdfstring{Lazy\+Open\+Stream}{LazyOpenStream}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md673}
{\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Lazy\+Open\+Stream}

Lazily reads or writes to a file that is opened only after an IO operation take place on the stream.


\begin{DoxyCode}{0}
\DoxyCodeLine{use\ \mbox{\hyperlink{namespace_guzzle_http_1_1_psr7}{GuzzleHttp\(\backslash\)Psr7}};}
\DoxyCodeLine{}
\DoxyCodeLine{\$stream\ =\ \textcolor{keyword}{new}\ Psr7\(\backslash\)LazyOpenStream(\textcolor{stringliteral}{'/path/to/file'},\ \textcolor{charliteral}{'r'});}
\DoxyCodeLine{\textcolor{comment}{//\ The\ file\ has\ not\ yet\ been\ opened...}}
\DoxyCodeLine{}
\DoxyCodeLine{echo\ \$stream-\/>read(10);}
\DoxyCodeLine{\textcolor{comment}{//\ The\ file\ is\ opened\ and\ read\ from\ only\ when\ needed.}}

\end{DoxyCode}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md674}{}\doxysection{\texorpdfstring{Limit\+Stream}{LimitStream}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md674}
{\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Limit\+Stream}

Limit\+Stream can be used to read a subset or slice of an existing stream object. This can be useful for breaking a large file into smaller pieces to be sent in chunks (e.\+g. Amazon S3\textquotesingle{}s multipart upload API).


\begin{DoxyCode}{0}
\DoxyCodeLine{use\ \mbox{\hyperlink{namespace_guzzle_http_1_1_psr7}{GuzzleHttp\(\backslash\)Psr7}};}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{namespace_illuminate_1_1_database_1_1_eloquent_1_1_concerns_aaf21c024e741a75af29e50e0046db8b3}{\$original}}\ =\ Psr7\(\backslash\)Utils::streamFor(fopen(\textcolor{stringliteral}{'/tmp/test.txt'},\ \textcolor{stringliteral}{'r+'}));}
\DoxyCodeLine{echo\ \mbox{\hyperlink{namespace_illuminate_1_1_database_1_1_eloquent_1_1_concerns_aaf21c024e741a75af29e50e0046db8b3}{\$original}}-\/>getSize();}
\DoxyCodeLine{\textcolor{comment}{//\ >>>\ 1048576}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Limit\ the\ size\ of\ the\ body\ to\ 1024\ bytes\ and\ start\ reading\ from\ byte\ 2048}}
\DoxyCodeLine{\$stream\ =\ \textcolor{keyword}{new}\ Psr7\(\backslash\)LimitStream(\$original,\ 1024,\ 2048);}
\DoxyCodeLine{echo\ \$stream-\/>getSize();}
\DoxyCodeLine{\textcolor{comment}{//\ >>>\ 1024}}
\DoxyCodeLine{echo\ \$stream-\/>tell();}
\DoxyCodeLine{\textcolor{comment}{//\ >>>\ 0}}

\end{DoxyCode}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md675}{}\doxysection{\texorpdfstring{Multipart\+Stream}{MultipartStream}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md675}
{\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Multipart\+Stream}

Stream that when read returns bytes for a streaming multipart or multipart/form-\/data stream.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md676}{}\doxysection{\texorpdfstring{No\+Seek\+Stream}{NoSeekStream}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md676}
{\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}No\+Seek\+Stream}

No\+Seek\+Stream wraps a stream and does not allow seeking.


\begin{DoxyCode}{0}
\DoxyCodeLine{use\ \mbox{\hyperlink{namespace_guzzle_http_1_1_psr7}{GuzzleHttp\(\backslash\)Psr7}};}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{namespace_illuminate_1_1_database_1_1_eloquent_1_1_concerns_aaf21c024e741a75af29e50e0046db8b3}{\$original}}\ =\ Psr7\(\backslash\)Utils::streamFor(\textcolor{stringliteral}{'foo'});}
\DoxyCodeLine{\$noSeek\ =\ \textcolor{keyword}{new}\ Psr7\(\backslash\)NoSeekStream(\$original);}
\DoxyCodeLine{}
\DoxyCodeLine{echo\ \$noSeek-\/>read(3);}
\DoxyCodeLine{\textcolor{comment}{//\ foo}}
\DoxyCodeLine{var\_export(\$noSeek-\/>isSeekable());}
\DoxyCodeLine{\textcolor{comment}{//\ false}}
\DoxyCodeLine{\$noSeek-\/>seek(0);}
\DoxyCodeLine{var\_export(\$noSeek-\/>read(3));}
\DoxyCodeLine{\textcolor{comment}{//\ NULL}}

\end{DoxyCode}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md677}{}\doxysection{\texorpdfstring{Pump\+Stream}{PumpStream}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md677}
{\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Pump\+Stream}

Provides a read only stream that pumps data from a PHP callable.

When invoking the provided callable, the Pump\+Stream will pass the amount of data requested to read to the callable. The callable can choose to ignore this value and return fewer or more bytes than requested. Any extra data returned by the provided callable is buffered internally until drained using the read() function of the Pump\+Stream. The provided callable MUST return false when there is no more data to read.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md678}{}\doxysection{\texorpdfstring{Implementing stream decorators}{Implementing stream decorators}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md678}
Creating a stream decorator is very easy thanks to the {\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Stream\+Decorator\+Trait}. This trait provides methods that implement {\ttfamily Psr\textbackslash{}Http\textbackslash{}Message\textbackslash{}Stream\+Interface} by proxying to an underlying stream. Just {\ttfamily use} the {\ttfamily Stream\+Decorator\+Trait} and implement your custom methods.

For example, let\textquotesingle{}s say we wanted to call a specific function each time the last byte is read from a stream. This could be implemented by overriding the {\ttfamily read()} method.


\begin{DoxyCode}{0}
\DoxyCodeLine{use\ \mbox{\hyperlink{interface_psr_1_1_http_1_1_message_1_1_stream_interface}{Psr\(\backslash\)Http\(\backslash\)Message\(\backslash\)StreamInterface}};}
\DoxyCodeLine{use\ GuzzleHttp\(\backslash\)Psr7\(\backslash\)StreamDecoratorTrait;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class\ }EofCallbackStream\ \textcolor{keyword}{implements}\ StreamInterface}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ use\ StreamDecoratorTrait;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{private}\ \$callback;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{private}\ \$stream;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keyword}{function}\ \mbox{\hyperlink{namespace_illuminate_1_1_testing_1_1_concerns_a17ea103c75f2b56cb4ebd89dbf59d2d6}{\_\_construct}}(StreamInterface\ \$stream,\ callable\ \$cb)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \$this-\/>stream\ =\ \$stream;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \$this-\/>callback\ =\ \$cb;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}\ \textcolor{keyword}{function}\ read(\$length)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \$result\ =\ \$this-\/>stream-\/>read(\$length);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Invoke\ the\ callback\ when\ EOF\ is\ hit.}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\$this-\/>eof())\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ call\_user\_func(\$this-\/>callback);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \$result;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


This decorator could be added to any existing stream and used like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{use\ \mbox{\hyperlink{namespace_guzzle_http_1_1_psr7}{GuzzleHttp\(\backslash\)Psr7}};}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{namespace_illuminate_1_1_database_1_1_eloquent_1_1_concerns_aaf21c024e741a75af29e50e0046db8b3}{\$original}}\ =\ Psr7\(\backslash\)Utils::streamFor(\textcolor{stringliteral}{'foo'});}
\DoxyCodeLine{}
\DoxyCodeLine{\$eofStream\ =\ \textcolor{keyword}{new}\ EofCallbackStream(\$original,\ \textcolor{keyword}{function}\ ()\ \{}
\DoxyCodeLine{\ \ \ \ echo\ \textcolor{stringliteral}{'EOF!'};}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{\$eofStream-\/>read(2);}
\DoxyCodeLine{\$eofStream-\/>read(1);}
\DoxyCodeLine{\textcolor{comment}{//\ echoes\ "{}EOF!"{}}}
\DoxyCodeLine{\$eofStream-\/>seek(0);}
\DoxyCodeLine{\$eofStream-\/>read(3);}
\DoxyCodeLine{\textcolor{comment}{//\ echoes\ "{}EOF!"{}}}

\end{DoxyCode}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md679}{}\doxysection{\texorpdfstring{PHP Stream\+Wrapper}{PHP StreamWrapper}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md679}
You can use the {\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Stream\+Wrapper} class if you need to use a PSR-\/7 stream as a PHP stream resource.

Use the {\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Stream\+Wrapper\+::get\+Resource()} method to create a PHP stream from a PSR-\/7 stream.


\begin{DoxyCode}{0}
\DoxyCodeLine{use\ \mbox{\hyperlink{class_guzzle_http_1_1_psr7_1_1_stream_wrapper}{GuzzleHttp\(\backslash\)Psr7\(\backslash\)StreamWrapper}};}
\DoxyCodeLine{}
\DoxyCodeLine{\$stream\ =\ GuzzleHttp\(\backslash\)Psr7\(\backslash\)Utils::streamFor(\textcolor{stringliteral}{'hello!'});}
\DoxyCodeLine{\$resource\ =\ StreamWrapper::getResource(\$stream);}
\DoxyCodeLine{echo\ fread(\$resource,\ 6);\ \textcolor{comment}{//\ outputs\ hello!}}

\end{DoxyCode}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md680}{}\doxysection{\texorpdfstring{Static API}{Static API}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md680}
There are various static methods available under the {\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7} namespace.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md681}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Message\+::to\+String$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Message::toString</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md681}
{\ttfamily public static function to\+String(Message\+Interface \$message)\+: string}

Returns the string representation of an HTTP message.


\begin{DoxyCode}{0}
\DoxyCodeLine{\$request\ =\ \textcolor{keyword}{new}\ \mbox{\hyperlink{class_guzzle_http_1_1_psr7_1_1_request}{GuzzleHttp\(\backslash\)Psr7\(\backslash\)Request}}(\textcolor{stringliteral}{'GET'},\ \textcolor{stringliteral}{'http://example.com'});}
\DoxyCodeLine{echo\ GuzzleHttp\(\backslash\)Psr7\(\backslash\)Message::toString(\$request);}

\end{DoxyCode}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md682}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Message\+::body\+Summary$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Message::bodySummary</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md682}
{\ttfamily public static function body\+Summary(Message\+Interface \$message, int \$truncate\+At = 120)\+: string\texorpdfstring{$\vert$}{|}null}

Get a short summary of the message body.

Will return {\ttfamily null} if the response is not printable.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md683}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Message\+::rewind\+Body$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Message::rewindBody</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md683}
{\ttfamily public static function rewind\+Body(Message\+Interface \$message)\+: void}

Attempts to rewind a message body and throws an exception on failure.

The body of the message will only be rewound if a call to {\ttfamily tell()} returns a value other than {\ttfamily 0}.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md684}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Message\+::parse\+Message$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Message::parseMessage</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md684}
{\ttfamily public static function parse\+Message(string \$message)\+: array}

Parses an HTTP message into an associative array.

The array contains the "{}start-\/line"{} key containing the start line of the message, "{}headers"{} key containing an associative array of header array values, and a "{}body"{} key containing the body of the message.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md685}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Message\+::parse\+Request\+Uri$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Message::parseRequestUri</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md685}
{\ttfamily public static function parse\+Request\+Uri(string \$path, array \$headers)\+: string}

Constructs a URI for an HTTP request message.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md686}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Message\+::parse\+Request$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Message::parseRequest</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md686}
{\ttfamily public static function parse\+Request(string \$message)\+: Request}

Parses a request message string into a request object.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md687}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Message\+::parse\+Response$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Message::parseResponse</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md687}
{\ttfamily public static function parse\+Response(string \$message)\+: Response}

Parses a response message string into a response object.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md688}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Header\+::parse$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Header::parse</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md688}
{\ttfamily public static function parse(string\texorpdfstring{$\vert$}{|}array \$header)\+: array}

Parse an array of header values containing "{};"{} separated data into an array of associative arrays representing the header key value pair data of the header. When a parameter does not contain a value, but just contains a key, this function will inject a key with a \textquotesingle{}\textquotesingle{} string value.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md689}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Header\+::split\+List$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Header::splitList</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md689}
{\ttfamily public static function split\+List(string\texorpdfstring{$\vert$}{|}string\mbox{[}\mbox{]} \$header)\+: string\mbox{[}\mbox{]}}

Splits a HTTP header defined to contain a comma-\/separated list into each individual value\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\$knownEtags\ =\ Header::splitList(\$request-\/>getHeader('if-\/none-\/match'));}

\end{DoxyCode}


Example headers include {\ttfamily accept}, {\ttfamily cache-\/control} and {\ttfamily if-\/none-\/match}.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md690}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Header\+::normalize$<$/tt$>$ (deprecated)}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Header::normalize</tt> (deprecated)}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md690}
{\ttfamily public static function normalize(string\texorpdfstring{$\vert$}{|}array \$header)\+: array}

{\ttfamily Header\+::normalize()} is deprecated in favor of \href{README.md\#guzzlehttppsr7headersplitlist}{\texttt{ {\ttfamily Header\+::split\+List()}}} which performs the same operation with a cleaned up API and improved documentation.

Converts an array of header values that may contain comma separated headers into an array of headers with no comma separated values.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md691}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Query\+::parse$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Query::parse</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md691}
{\ttfamily public static function parse(string \$str, int\texorpdfstring{$\vert$}{|}bool \$url\+Encoding = true)\+: array}

Parse a query string into an associative array.

If multiple values are found for the same key, the value of that key value pair will become an array. This function does not parse nested PHP style arrays into an associative array (e.\+g., {\ttfamily foo\mbox{[}a\mbox{]}=1\&foo\mbox{[}b\mbox{]}=2} will be parsed into `\mbox{[}\textquotesingle{}foo\mbox{[}a\mbox{]}' =\texorpdfstring{$>$}{>} \textquotesingle{}1\textquotesingle{}, \textquotesingle{}foo\mbox{[}b\mbox{]}\textquotesingle{} =\texorpdfstring{$>$}{>} \textquotesingle{}2\textquotesingle{}\mbox{]})\`{}.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md692}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Query\+::build$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Query::build</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md692}
{\ttfamily public static function build(array \$params, int\texorpdfstring{$\vert$}{|}false \$encoding = PHP\+\_\+\+QUERY\+\_\+\+RFC3986)\+: string}

Build a query string from an array of key value pairs.

This function can use the return value of {\ttfamily parse()} to build a query string. This function does not modify the provided keys when an array is encountered (like {\ttfamily http\+\_\+build\+\_\+query()} would).\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md693}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Utils\+::caseless\+Remove$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Utils::caselessRemove</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md693}
{\ttfamily public static function caseless\+Remove(iterable\texorpdfstring{$<$}{<}string\texorpdfstring{$>$}{>} \$keys, \$keys, array \$data)\+: array}

Remove the items given by the keys, case insensitively from the data.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md694}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Utils\+::copy\+To\+Stream$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Utils::copyToStream</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md694}
{\ttfamily public static function copy\+To\+Stream(Stream\+Interface \$source, Stream\+Interface \$dest, int \$max\+Len = -\/1)\+: void}

Copy the contents of a stream into another stream until the given number of bytes have been read.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md695}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Utils\+::copy\+To\+String$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Utils::copyToString</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md695}
{\ttfamily public static function copy\+To\+String(Stream\+Interface \$stream, int \$max\+Len = -\/1)\+: string}

Copy the contents of a stream into a string until the given number of bytes have been read.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md696}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Utils\+::hash$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Utils::hash</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md696}
{\ttfamily public static function hash(Stream\+Interface \$stream, string \$algo, bool \$raw\+Output = false)\+: string}

Calculate a hash of a stream.

This method reads the entire stream to calculate a rolling hash, based on PHP\textquotesingle{}s {\ttfamily hash\+\_\+init} functions.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md697}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Utils\+::modify\+Request$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Utils::modifyRequest</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md697}
{\ttfamily public static function modify\+Request(Request\+Interface \$request, array \$changes)\+: Request\+Interface}

Clone and modify a request with the given changes.

This method is useful for reducing the number of clones needed to mutate a message.


\begin{DoxyItemize}
\item method\+: (string) Changes the HTTP method.
\item set\+\_\+headers\+: (array) Sets the given headers.
\item remove\+\_\+headers\+: (array) Remove the given headers.
\item body\+: (mixed) Sets the given body.
\item uri\+: (Uri\+Interface) Set the URI.
\item query\+: (string) Set the query string value of the URI.
\item version\+: (string) Set the protocol version.
\end{DoxyItemize}\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md698}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Utils\+::read\+Line$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Utils::readLine</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md698}
{\ttfamily public static function read\+Line(Stream\+Interface \$stream, int \$max\+Length = null)\+: string}

Read a line from the stream up to the maximum allowed buffer length.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md699}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Utils\+::stream\+For$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Utils::streamFor</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md699}
`public static function stream\+For(resource\texorpdfstring{$\vert$}{|}string\texorpdfstring{$\vert$}{|}null\texorpdfstring{$\vert$}{|}int\texorpdfstring{$\vert$}{|}float\texorpdfstring{$\vert$}{|}bool\texorpdfstring{$\vert$}{|}\+Stream\+Interface\texorpdfstring{$\vert$}{|}callable\texorpdfstring{$\vert$}{|}\textbackslash{}\+Iterator \$resource = '\textquotesingle{}, array \$options = \mbox{[}\mbox{]})\+: Stream\+Interface\`{}

Create a new stream based on the input type.

Options is an associative array that can contain the following keys\+:


\begin{DoxyItemize}
\item metadata\+: Array of custom metadata.
\item size\+: Size of the stream.
\end{DoxyItemize}

This method accepts the following {\ttfamily \$resource} types\+:


\begin{DoxyItemize}
\item {\ttfamily Psr\textbackslash{}Http\textbackslash{}Message\textbackslash{}Stream\+Interface}\+: Returns the value as-\/is.
\item {\ttfamily string}\+: Creates a stream object that uses the given string as the contents.
\item {\ttfamily resource}\+: Creates a stream object that wraps the given PHP stream resource.
\item {\ttfamily Iterator}\+: If the provided value implements {\ttfamily Iterator}, then a read-\/only stream object will be created that wraps the given iterable. Each time the stream is read from, data from the iterator will fill a buffer and will be continuously called until the buffer is equal to the requested read size. Subsequent read calls will first read from the buffer and then call {\ttfamily next} on the underlying iterator until it is exhausted.
\item {\ttfamily object} with {\ttfamily \+\_\+\+\_\+to\+String()}\+: If the object has the {\ttfamily \+\_\+\+\_\+to\+String()} method, the object will be cast to a string and then a stream will be returned that uses the string value.
\item {\ttfamily NULL}\+: When {\ttfamily null} is passed, an empty stream object is returned.
\item {\ttfamily callable} When a callable is passed, a read-\/only stream object will be created that invokes the given callable. The callable is invoked with the number of suggested bytes to read. The callable can return any number of bytes, but MUST return {\ttfamily false} when there is no more data to return. The stream object that wraps the callable will invoke the callable until the number of requested bytes are available. Any additional bytes will be buffered and used in subsequent reads.
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{\$stream\ =\ GuzzleHttp\(\backslash\)Psr7\(\backslash\)Utils::streamFor(\textcolor{stringliteral}{'foo'});}
\DoxyCodeLine{\$stream\ =\ GuzzleHttp\(\backslash\)Psr7\(\backslash\)Utils::streamFor(fopen(\textcolor{stringliteral}{'/path/to/file'},\ \textcolor{charliteral}{'r'}));}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{hamcrest_2hamcrest-php_2generator_2_run_8php_ab328ac5b606185b5e1706aa41380cc76}{\$generator}}\ =\ \textcolor{keyword}{function}\ (\$bytes)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{for}\ (\$i\ =\ 0;\ \$i\ <\ \$bytes;\ \$i++)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ yield\ \textcolor{charliteral}{'\ '};}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\$stream\ =\ GuzzleHttp\(\backslash\)Psr7\(\backslash\)Utils::streamFor(\mbox{\hyperlink{hamcrest_2hamcrest-php_2generator_2_run_8php_ab328ac5b606185b5e1706aa41380cc76}{\$generator}}(100));}

\end{DoxyCode}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md700}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Utils\+::try\+Fopen$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Utils::tryFopen</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md700}
{\ttfamily public static function try\+Fopen(string \$filename, string \$mode)\+: resource}

Safely opens a PHP stream resource using a filename.

When fopen fails, PHP normally raises a warning. This function adds an error handler that checks for errors and throws an exception instead.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md701}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Utils\+::try\+Get\+Contents$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Utils::tryGetContents</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md701}
{\ttfamily public static function try\+Get\+Contents(resource \$stream)\+: string}

Safely gets the contents of a given stream.

When stream\+\_\+get\+\_\+contents fails, PHP normally raises a warning. This function adds an error handler that checks for errors and throws an exception instead.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md702}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Utils\+::uri\+For$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Utils::uriFor</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md702}
{\ttfamily public static function uri\+For(string\texorpdfstring{$\vert$}{|}\+Uri\+Interface \$uri)\+: Uri\+Interface}

Returns a Uri\+Interface for the given value.

This function accepts a string or Uri\+Interface and returns a Uri\+Interface for the given value. If the value is already a Uri\+Interface, it is returned as-\/is.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md703}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Mime\+Type\+::from\+Filename$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}MimeType::fromFilename</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md703}
{\ttfamily public static function from\+Filename(string \$filename)\+: string\texorpdfstring{$\vert$}{|}null}

Determines the mimetype of a file by looking at its extension.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md704}{}\doxysubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Mime\+Type\+::from\+Extension$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}MimeType::fromExtension</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md704}
{\ttfamily public static function from\+Extension(string \$extension)\+: string\texorpdfstring{$\vert$}{|}null}

Maps a file extensions to a mimetype.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md705}{}\doxysubsection{\texorpdfstring{Upgrading from Function API}{Upgrading from Function API}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md705}
The static API was first introduced in 1.\+7.\+0, in order to mitigate problems with functions conflicting between global and local copies of the package. The function API was removed in 2.\+0.\+0. A migration table has been provided here for your convenience\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Original Function   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Replacement Method    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Original Function   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Replacement Method    }\\\cline{1-2}
\endhead
{\ttfamily str}   &{\ttfamily Message\+::to\+String}    \\\cline{1-2}
{\ttfamily uri\+\_\+for}   &{\ttfamily Utils\+::uri\+For}    \\\cline{1-2}
{\ttfamily stream\+\_\+for}   &{\ttfamily Utils\+::stream\+For}    \\\cline{1-2}
{\ttfamily parse\+\_\+header}   &{\ttfamily Header\+::parse}    \\\cline{1-2}
{\ttfamily normalize\+\_\+header}   &{\ttfamily Header\+::normalize}    \\\cline{1-2}
{\ttfamily modify\+\_\+request}   &{\ttfamily Utils\+::modify\+Request}    \\\cline{1-2}
{\ttfamily rewind\+\_\+body}   &{\ttfamily Message\+::rewind\+Body}    \\\cline{1-2}
{\ttfamily try\+\_\+fopen}   &{\ttfamily Utils\+::try\+Fopen}    \\\cline{1-2}
{\ttfamily copy\+\_\+to\+\_\+string}   &{\ttfamily Utils\+::copy\+To\+String}    \\\cline{1-2}
{\ttfamily copy\+\_\+to\+\_\+stream}   &{\ttfamily Utils\+::copy\+To\+Stream}    \\\cline{1-2}
{\ttfamily hash}   &{\ttfamily Utils\+::hash}    \\\cline{1-2}
{\ttfamily readline}   &{\ttfamily Utils\+::read\+Line}    \\\cline{1-2}
{\ttfamily parse\+\_\+request}   &{\ttfamily Message\+::parse\+Request}    \\\cline{1-2}
{\ttfamily parse\+\_\+response}   &{\ttfamily Message\+::parse\+Response}    \\\cline{1-2}
{\ttfamily parse\+\_\+query}   &{\ttfamily Query\+::parse}    \\\cline{1-2}
{\ttfamily build\+\_\+query}   &{\ttfamily Query\+::build}    \\\cline{1-2}
{\ttfamily mimetype\+\_\+from\+\_\+filename}   &{\ttfamily Mime\+Type\+::from\+Filename}    \\\cline{1-2}
{\ttfamily mimetype\+\_\+from\+\_\+extension}   &{\ttfamily Mime\+Type\+::from\+Extension}    \\\cline{1-2}
{\ttfamily \+\_\+parse\+\_\+message}   &{\ttfamily Message\+::parse\+Message}    \\\cline{1-2}
{\ttfamily \+\_\+parse\+\_\+request\+\_\+uri}   &{\ttfamily Message\+::parse\+Request\+Uri}    \\\cline{1-2}
{\ttfamily get\+\_\+message\+\_\+body\+\_\+summary}   &{\ttfamily Message\+::body\+Summary}    \\\cline{1-2}
{\ttfamily \+\_\+caseless\+\_\+remove}   &{\ttfamily Utils\+::caseless\+Remove}   \\\cline{1-2}
\end{longtabu}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md706}{}\doxysection{\texorpdfstring{Additional URI Methods}{Additional URI Methods}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md706}
Aside from the standard {\ttfamily Psr\textbackslash{}Http\textbackslash{}Message\textbackslash{}Uri\+Interface} implementation in form of the {\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Uri} class, this library also provides additional functionality when working with URIs as static methods.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md707}{}\doxysubsection{\texorpdfstring{URI Types}{URI Types}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md707}
An instance of {\ttfamily Psr\textbackslash{}Http\textbackslash{}Message\textbackslash{}Uri\+Interface} can either be an absolute URI or a relative reference. An absolute URI has a scheme. A relative reference is used to express a URI relative to another URI, the base URI. Relative references can be divided into several forms according to \href{https://tools.ietf.org/html/rfc3986\#section-4.2}{\texttt{ RFC 3986 Section 4.\+2}}\+:


\begin{DoxyItemize}
\item network-\/path references, e.\+g. {\ttfamily //example.com/path}
\item absolute-\/path references, e.\+g. {\ttfamily /path}
\item relative-\/path references, e.\+g. {\ttfamily subpath}
\end{DoxyItemize}

The following methods can be used to identify the type of the URI.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md708}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+::is\+Absolute$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Uri::isAbsolute</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md708}
{\ttfamily public static function is\+Absolute(Uri\+Interface \$uri)\+: bool}

Whether the URI is absolute, i.\+e. it has a scheme.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md709}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+::is\+Network\+Path\+Reference$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Uri::isNetworkPathReference</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md709}
{\ttfamily public static function is\+Network\+Path\+Reference(Uri\+Interface \$uri)\+: bool}

Whether the URI is a network-\/path reference. A relative reference that begins with two slash characters is termed an network-\/path reference.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md710}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+::is\+Absolute\+Path\+Reference$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Uri::isAbsolutePathReference</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md710}
{\ttfamily public static function is\+Absolute\+Path\+Reference(Uri\+Interface \$uri)\+: bool}

Whether the URI is a absolute-\/path reference. A relative reference that begins with a single slash character is termed an absolute-\/path reference.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md711}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+::is\+Relative\+Path\+Reference$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Uri::isRelativePathReference</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md711}
{\ttfamily public static function is\+Relative\+Path\+Reference(Uri\+Interface \$uri)\+: bool}

Whether the URI is a relative-\/path reference. A relative reference that does not begin with a slash character is termed a relative-\/path reference.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md712}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+::is\+Same\+Document\+Reference$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Uri::isSameDocumentReference</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md712}
{\ttfamily public static function is\+Same\+Document\+Reference(Uri\+Interface \$uri, Uri\+Interface \$base = null)\+: bool}

Whether the URI is a same-\/document reference. A same-\/document reference refers to a URI that is, aside from its fragment component, identical to the base URI. When no base URI is given, only an empty URI reference (apart from its fragment) is considered a same-\/document reference.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md713}{}\doxysubsection{\texorpdfstring{URI Components}{URI Components}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md713}
Additional methods to work with URI components.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md714}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+::is\+Default\+Port$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Uri::isDefaultPort</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md714}
{\ttfamily public static function is\+Default\+Port(Uri\+Interface \$uri)\+: bool}

Whether the URI has the default port of the current scheme. {\ttfamily Psr\textbackslash{}Http\textbackslash{}Message\textbackslash{}Uri\+Interface\+::get\+Port} may return null or the standard port. This method can be used independently of the implementation.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md715}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+::compose\+Components$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Uri::composeComponents</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md715}
{\ttfamily public static function compose\+Components(\$scheme, \$authority, \$path, \$query, \$fragment)\+: string}

Composes a URI reference string from its various components according to \href{https://tools.ietf.org/html/rfc3986\#section-5.3}{\texttt{ RFC 3986 Section 5.\+3}}. Usually this method does not need to be called manually but instead is used indirectly via {\ttfamily Psr\textbackslash{}Http\textbackslash{}Message\textbackslash{}Uri\+Interface\+::\+\_\+\+\_\+to\+String}.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md716}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+::from\+Parts$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Uri::fromParts</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md716}
{\ttfamily public static function from\+Parts(array \$parts)\+: Uri\+Interface}

Creates a URI from a hash of \href{https://www.php.net/manual/en/function.parse-url.php}{\texttt{ {\ttfamily parse\+\_\+url}}} components.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md717}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+::with\+Query\+Value$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Uri::withQueryValue</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md717}
{\ttfamily public static function with\+Query\+Value(Uri\+Interface \$uri, \$key, \$value)\+: Uri\+Interface}

Creates a new URI with a specific query string value. Any existing query string values that exactly match the provided key are removed and replaced with the given key value pair. A value of null will set the query string key without a value, e.\+g. "{}key"{} instead of "{}key=value"{}.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md718}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+::with\+Query\+Values$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Uri::withQueryValues</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md718}
{\ttfamily public static function with\+Query\+Values(Uri\+Interface \$uri, array \$key\+Value\+Array)\+: Uri\+Interface}

Creates a new URI with multiple query string values. It has the same behavior as {\ttfamily with\+Query\+Value()} but for an associative array of key =\texorpdfstring{$>$}{>} value.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md719}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+::without\+Query\+Value$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}Uri::withoutQueryValue</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md719}
{\ttfamily public static function without\+Query\+Value(Uri\+Interface \$uri, \$key)\+: Uri\+Interface}

Creates a new URI with a specific query string value removed. Any existing query string values that exactly match the provided key are removed.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md720}{}\doxysubsection{\texorpdfstring{Cross-\/\+Origin Detection}{Cross-Origin Detection}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md720}
{\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Uri\+Comparator} provides methods to determine if a modified URL should be considered cross-\/origin.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md721}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+Comparator\+::is\+Cross\+Origin$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}UriComparator::isCrossOrigin</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md721}
{\ttfamily public static function is\+Cross\+Origin(Uri\+Interface \$original, Uri\+Interface \$modified)\+: bool}

Determines if a modified URL should be considered cross-\/origin with respect to an original URL.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md722}{}\doxysubsection{\texorpdfstring{Reference Resolution}{Reference Resolution}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md722}
{\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Uri\+Resolver} provides methods to resolve a URI reference in the context of a base URI according to \href{https://tools.ietf.org/html/rfc3986\#section-5}{\texttt{ RFC 3986 Section 5}}. This is for example also what web browsers do when resolving a link in a website based on the current request URI.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md723}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+Resolver\+::resolve$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}UriResolver::resolve</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md723}
{\ttfamily public static function resolve(Uri\+Interface \$base, Uri\+Interface \$rel)\+: Uri\+Interface}

Converts the relative URI into a new URI that is resolved against the base URI.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md724}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+Resolver\+::remove\+Dot\+Segments$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}UriResolver::removeDotSegments</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md724}
{\ttfamily public static function remove\+Dot\+Segments(string \$path)\+: string}

Removes dot segments from a path and returns the new path according to \href{https://tools.ietf.org/html/rfc3986\#section-5.2.4}{\texttt{ RFC 3986 Section 5.\+2.\+4}}.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md725}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+Resolver\+::relativize$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}UriResolver::relativize</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md725}
{\ttfamily public static function relativize(Uri\+Interface \$base, Uri\+Interface \$target)\+: Uri\+Interface}

Returns the target URI as a relative reference from the base URI. This method is the counterpart to resolve()\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{(string)\ \$target\ ===\ (\textcolor{keywordtype}{string})\ UriResolver::resolve(\$base,\ UriResolver::relativize(\$base,\ \$target))}

\end{DoxyCode}


One use-\/case is to use the current request URI as base URI and then generate relative links in your documents to reduce the document size or offer self-\/contained downloadable document archives.


\begin{DoxyCode}{0}
\DoxyCodeLine{\$base\ =\ \textcolor{keyword}{new}\ Uri(\textcolor{stringliteral}{'http://example.com/a/b/'});}
\DoxyCodeLine{echo\ UriResolver::relativize(\$base,\ \textcolor{keyword}{new}\ Uri(\textcolor{stringliteral}{'http://example.com/a/b/c'}));\ \ \textcolor{comment}{//\ prints\ 'c'.}}
\DoxyCodeLine{echo\ UriResolver::relativize(\$base,\ \textcolor{keyword}{new}\ Uri(\textcolor{stringliteral}{'http://example.com/a/x/y'}));\ \ \textcolor{comment}{//\ prints\ '../x/y'.}}
\DoxyCodeLine{echo\ UriResolver::relativize(\$base,\ \textcolor{keyword}{new}\ Uri(\textcolor{stringliteral}{'http://example.com/a/b/?q'}));\ \textcolor{comment}{//\ prints\ '?q'.}}
\DoxyCodeLine{echo\ UriResolver::relativize(\$base,\ \textcolor{keyword}{new}\ Uri(\textcolor{stringliteral}{'http://example.org/a/b/'}));\ \ \ \textcolor{comment}{//\ prints\ '//example.org/a/b/'.}}

\end{DoxyCode}
\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md726}{}\doxysubsection{\texorpdfstring{Normalization and Comparison}{Normalization and Comparison}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md726}
{\ttfamily \doxylink{namespace_guzzle_http}{Guzzle\+Http}\textbackslash{}Psr7\textbackslash{}Uri\+Normalizer} provides methods to normalize and compare URIs according to \href{https://tools.ietf.org/html/rfc3986\#section-6}{\texttt{ RFC 3986 Section 6}}.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md727}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+Normalizer\+::normalize$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}UriNormalizer::normalize</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md727}
{\ttfamily public static function normalize(Uri\+Interface \$uri, \$flags = self\+::\+PRESERVING\+\_\+\+NORMALIZATIONS)\+: Uri\+Interface}

Returns a normalized URI. The scheme and host component are already normalized to lowercase per PSR-\/7 Uri\+Interface. This methods adds additional normalizations that can be configured with the {\ttfamily \$flags} parameter which is a bitmask of normalizations to apply. The following normalizations are available\+:


\begin{DoxyItemize}
\item {\ttfamily Uri\+Normalizer\+::\+PRESERVING\+\_\+\+NORMALIZATIONS}

Default normalizations which only include the ones that preserve semantics.
\item {\ttfamily Uri\+Normalizer\+::\+CAPITALIZE\+\_\+\+PERCENT\+\_\+\+ENCODING}

All letters within a percent-\/encoding triplet (e.\+g., "{}\%3\+A"{}) are case-\/insensitive, and should be capitalized.

Example\+: {\ttfamily \href{http://example.org/a\%c2\%b1b}{\texttt{ http\+://example.\+org/a\%c2\%b1b}}} → {\ttfamily \href{http://example.org/a\%C2\%B1b}{\texttt{ http\+://example.\+org/a\%\+C2\%\+B1b}}}
\item {\ttfamily Uri\+Normalizer\+::\+DECODE\+\_\+\+UNRESERVED\+\_\+\+CHARACTERS}

Decodes percent-\/encoded octets of unreserved characters. For consistency, percent-\/encoded octets in the ranges of ALPHA (\%41–\%5A and \%61–\%7A), DIGIT (\%30–\%39), hyphen (\%2D), period (\%2E), underscore (\%5F), or tilde (\%7E) should not be created by URI producers and, when found in a URI, should be decoded to their corresponding unreserved characters by URI normalizers.

Example\+: {\ttfamily \href{http://example.org/\%7Eusern\%61me/}{\texttt{ http\+://example.\+org/\%7\+Eusern\%61me/}}} → {\ttfamily \href{http://example.org/~username/}{\texttt{ http\+://example.\+org/\texorpdfstring{$\sim$}{\string~}username/}}}
\item {\ttfamily Uri\+Normalizer\+::\+CONVERT\+\_\+\+EMPTY\+\_\+\+PATH}

Converts the empty path to "{}/"{} for http and https URIs.

Example\+: {\ttfamily \href{http://example.org}{\texttt{ http\+://example.\+org}}} → {\ttfamily \href{http://example.org/}{\texttt{ http\+://example.\+org/}}}
\item {\ttfamily Uri\+Normalizer\+::\+REMOVE\+\_\+\+DEFAULT\+\_\+\+HOST}

Removes the default host of the given URI scheme from the URI. Only the "{}file"{} scheme defines the default host "{}localhost"{}. All of {\ttfamily \href{file:/myfile}{\texttt{ file\+:/myfile}}}, {\ttfamily \href{file:///myfile}{\texttt{ file\+:///myfile}}}, and {\ttfamily \href{file://localhost/myfile}{\texttt{ file\+://localhost/myfile}}} are equivalent according to RFC 3986.

Example\+: {\ttfamily \href{file://localhost/myfile}{\texttt{ file\+://localhost/myfile}}} → {\ttfamily \href{file:///myfile}{\texttt{ file\+:///myfile}}}
\item {\ttfamily Uri\+Normalizer\+::\+REMOVE\+\_\+\+DEFAULT\+\_\+\+PORT}

Removes the default port of the given URI scheme from the URI.

Example\+: {\ttfamily \href{http://example.org:80/}{\texttt{ http\+://example.\+org\+:80/}}} → {\ttfamily \href{http://example.org/}{\texttt{ http\+://example.\+org/}}}
\item {\ttfamily Uri\+Normalizer\+::\+REMOVE\+\_\+\+DOT\+\_\+\+SEGMENTS}

Removes unnecessary dot-\/segments. Dot-\/segments in relative-\/path references are not removed as it would change the semantics of the URI reference.

Example\+: {\ttfamily \href{http://example.org/../a/b/../c/./d.html}{\texttt{ http\+://example.\+org/../a/b/../c/./d.\+html}}} → {\ttfamily \href{http://example.org/a/c/d.html}{\texttt{ http\+://example.\+org/a/c/d.\+html}}}
\item {\ttfamily Uri\+Normalizer\+::\+REMOVE\+\_\+\+DUPLICATE\+\_\+\+SLASHES}

Paths which include two or more adjacent slashes are converted to one. Webservers usually ignore duplicate slashes and treat those URIs equivalent. But in theory those URIs do not need to be equivalent. So this normalization may change the semantics. Encoded slashes (\%2F) are not removed.

Example\+: {\ttfamily \href{http://example.org//foo///bar.html}{\texttt{ http\+://example.\+org//foo///bar.\+html}}} → {\ttfamily \href{http://example.org/foo/bar.html}{\texttt{ http\+://example.\+org/foo/bar.\+html}}}
\item {\ttfamily Uri\+Normalizer\+::\+SORT\+\_\+\+QUERY\+\_\+\+PARAMETERS}

Sort query parameters with their values in alphabetical order. However, the order of parameters in a URI may be significant (this is not defined by the standard). So this normalization is not safe and may change the semantics of the URI.

Example\+: {\ttfamily ?lang=en\&article=fred} → {\ttfamily ?article=fred\&lang=en}
\end{DoxyItemize}\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md728}{}\doxysubsubsection{\texorpdfstring{$<$tt$>$\+Guzzle\+Http\textbackslash{}\+Psr7\textbackslash{}\+Uri\+Normalizer\+::is\+Equivalent$<$/tt$>$}{<tt>GuzzleHttp\textbackslash{}Psr7\textbackslash{}UriNormalizer::isEquivalent</tt>}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md728}
{\ttfamily public static function is\+Equivalent(Uri\+Interface \$uri1, Uri\+Interface \$uri2, \$normalizations = self\+::\+PRESERVING\+\_\+\+NORMALIZATIONS)\+: bool}

Whether two URIs can be considered equivalent. Both URIs are normalized automatically before comparison with the given {\ttfamily \$normalizations} bitmask. The method also accepts relative URI references and returns true when they are equivalent. This of course assumes they will be resolved against the same base URI. If this is not the case, determination of equivalence or difference of relative references does not mean anything.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md729}{}\doxysubsection{\texorpdfstring{Security}{Security}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md729}
If you discover a security vulnerability within this package, please send an email to \href{mailto:security@tidelift.com}{\texttt{ security@tidelift.\+com}}. All security vulnerabilities will be promptly addressed. Please do not disclose security-\/related issues publicly until a fix has been announced. Please see \href{https://github.com/guzzle/psr7/security/policy}{\texttt{ Security Policy}} for more information.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md730}{}\doxysubsection{\texorpdfstring{License}{License}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md730}
Guzzle is made available under the MIT License (MIT). Please see \mbox{[}License File\mbox{]}(LICENSE) for more information.\hypertarget{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md731}{}\doxysubsection{\texorpdfstring{For Enterprise}{For Enterprise}}\label{md_vendor_2guzzlehttp_2psr7_2_r_e_a_d_m_e_autotoc_md731}
Available as part of the Tidelift Subscription

The maintainers of Guzzle and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. \href{https://tidelift.com/subscription/pkg/packagist-guzzlehttp-psr7?utm_source=packagist-guzzlehttp-psr7&utm_medium=referral&utm_campaign=enterprise&utm_term=repo}{\texttt{ Learn more.}} 